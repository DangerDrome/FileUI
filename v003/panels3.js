(function() {
    'use strict';

    // ===== DEFAULT LAYOUT DATA =====
    const DEFAULT_LAYOUT = {
        "version": "1.0",
        "timestamp": "2025-07-03T06:39:44.916Z",
        "tree": {
            "id": "5ad14758-daac-4b2c-8592-fece794bdb50",
            "direction": "vertical",
            "split": 0.011787819253438114,
            "isPinned": false,
            "isCollapsed": false,
            "isMainContent": false,
            "isToolbar": false,
            "children": [
                {
                    "id": "panel-2-1751524681458",
                    "direction": null,
                    "split": 0.5,
                    "isPinned": true,
                    "isCollapsed": true,
                    "isMainContent": false,
                    "isToolbar": true,
                    "children": [],
                    "leaf": true
                },
                {
                    "id": "bd242593-1244-400d-be52-eb677bdc5a4d",
                    "direction": "vertical",
                    "split": 0.8791500988234562,
                    "isPinned": false,
                    "isCollapsed": false,
                    "isMainContent": false,
                    "isToolbar": false,
                    "children": [
                        {
                            "id": "7ee4d068-e236-477e-8ffe-39f1c7f01461",
                            "direction": "horizontal",
                            "split": 0.967802523190329,
                            "isPinned": false,
                            "isCollapsed": false,
                            "isMainContent": false,
                            "isToolbar": false,
                            "children": [
                                {
                                    "id": "d90ec94e-7e9f-4069-b1c3-ad3ab8afe391",
                                    "direction": "horizontal",
                                    "split": 0.07962138663646175,
                                    "isPinned": false,
                                    "isCollapsed": false,
                                    "isMainContent": false,
                                    "isToolbar": false,
                                    "children": [
                                        {
                                            "id": "panel-1-1751524681458",
                                            "direction": null,
                                            "split": 0.5,
                                            "isPinned": true,
                                            "isCollapsed": true,
                                            "isMainContent": false,
                                            "isToolbar": true,
                                            "children": [],
                                            "leaf": true
                                        },
                                        {
                                            "id": "cc44a063-87be-4a2f-b5e1-fda11ab4c7bd",
                                            "direction": "vertical",
                                            "split": 0.5,
                                            "isPinned": false,
                                            "isCollapsed": false,
                                            "isMainContent": false,
                                            "isToolbar": false,
                                            "children": [
                                                {
                                                    "id": "fc3915bc-6529-475d-9c4b-278e97199a3a",
                                                    "direction": "vertical",
                                                    "split": 0.2956653882609988,
                                                    "isPinned": false,
                                                    "isCollapsed": false,
                                                    "isMainContent": false,
                                                    "isToolbar": false,
                                                    "children": [
                                                        {
                                                            "id": "panel-3-1751524681459",
                                                            "direction": null,
                                                            "split": 0.5,
                                                            "isPinned": true,
                                                            "isCollapsed": false,
                                                            "isMainContent": false,
                                                            "isToolbar": false,
                                                            "children": [],
                                                            "leaf": true
                                                        },
                                                        {
                                                            "id": "df615640-943f-49d6-adf9-f3acc7f8dcd4",
                                                            "direction": "vertical",
                                                            "split": 0.5,
                                                            "isPinned": false,
                                                            "isCollapsed": false,
                                                            "isMainContent": false,
                                                            "isToolbar": false,
                                                            "children": [
                                                                {
                                                                    "id": "panel-10-1751524681464",
                                                                    "direction": null,
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "isToolbar": false,
                                                                    "children": [],
                                                                    "leaf": true
                                                                },
                                                                {
                                                                    "id": "panel-7-1751524681463",
                                                                    "direction": null,
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "isToolbar": false,
                                                                    "children": [],
                                                                    "leaf": true
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                },
                                                {
                                                    "id": "b49e17af-e8fd-4d2b-9b51-419e2bc72de2",
                                                    "direction": "horizontal",
                                                    "split": 0.5,
                                                    "isPinned": false,
                                                    "isCollapsed": false,
                                                    "isMainContent": false,
                                                    "isToolbar": false,
                                                    "children": [
                                                        {
                                                            "id": "panel-4-1751524681459",
                                                            "direction": null,
                                                            "split": 0.5,
                                                            "isPinned": false,
                                                            "isCollapsed": false,
                                                            "isMainContent": true,
                                                            "isToolbar": false,
                                                            "children": [],
                                                            "leaf": true
                                                        },
                                                        {
                                                            "id": "d2f995a6-d967-473e-b2b5-8c255fb7610a",
                                                            "direction": "vertical",
                                                            "split": 0.5,
                                                            "isPinned": false,
                                                            "isCollapsed": false,
                                                            "isMainContent": false,
                                                            "isToolbar": false,
                                                            "children": [
                                                                {
                                                                    "id": "panel-9-1751524681463",
                                                                    "direction": null,
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "isToolbar": false,
                                                                    "children": [],
                                                                    "leaf": true
                                                                },
                                                                {
                                                                    "id": "1955b473-21f1-45a1-a669-f56193aa419c",
                                                                    "direction": "horizontal",
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "isToolbar": false,
                                                                    "children": [
                                                                        {
                                                                            "id": "panel-8-1751524681463",
                                                                            "direction": null,
                                                                            "split": 0.5,
                                                                            "isPinned": false,
                                                                            "isCollapsed": false,
                                                                            "isMainContent": false,
                                                                            "isToolbar": false,
                                                                            "children": [],
                                                                            "leaf": true
                                                                        },
                                                                        {
                                                                            "id": "panel-11-1751524681464",
                                                                            "direction": null,
                                                                            "split": 0.5,
                                                                            "isPinned": false,
                                                                            "isCollapsed": false,
                                                                            "isMainContent": false,
                                                                            "isToolbar": false,
                                                                            "children": [],
                                                                            "leaf": true
                                                                        }
                                                                    ]
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "id": "panel-5-1751524681459",
                                    "direction": null,
                                    "split": 0.5,
                                    "isPinned": true,
                                    "isCollapsed": false,
                                    "isMainContent": false,
                                    "isToolbar": false,
                                    "children": [],
                                    "leaf": true
                                }
                            ]
                        },
                        {
                            "id": "panel-6-1751524681459",
                            "direction": null,
                            "split": 0.5,
                            "isPinned": true,
                            "isCollapsed": false,
                            "isMainContent": false,
                            "isToolbar": false,
                            "children": [],
                            "leaf": true
                        }
                    ]
                }
            ]
        },
        "markdown": {
            "panel-3-1751524681459": "",
            "panel-4-1751524681459": "# Responsive\n\nDraggable content area.",
            "panel-5-1751524681459": "",
            "panel-6-1751524681459": "",
            "panel-7-1751524681463": "# Efficient\n\nDraggable content area.",
            "panel-8-1751524681463": "# Efficient\n\nDraggable content area.",
            "panel-9-1751524681463": "# Modular\n\nDraggable content area.",
            "panel-10-1751524681464": "# Organized\n\nDraggable content area.",
            "panel-11-1751524681464": "# Fluid\n\nDraggable content area."
        },
        "panelCount": 12
    };

    // ===== CONFIGURATION =====
    const CONFIG = {
        RESIZER_THICKNESS: 5,
        PANEL_MIN_HEIGHT: 40,
        PANEL_MIN_WIDTH: 150,
        COLLAPSED_SIZE: 30, // Corresponds to header height/width
        DRAG_COLLAPSE_THRESHOLD: 20,
        DEFAULT_SPLIT: 0.5,
        HISTORY_LIMIT: 50,
        ANIMATION_DURATION: 150,
        EASING: 'cubic-bezier(0.4, 0, 0.2, 1)',
        PANEL_ANIMATION_CLASS: 'panel-grow-in',
    };

    // ===== UTILITY CLASSES =====

    /**
     * A simple event emitter for pub/sub communication.
     */
    class EventEmitter {
        constructor() {
            this.events = new Map();
        }
        on(event, listener) {
            if (!this.events.has(event)) {
                this.events.set(event, []);
            }
            this.events.get(event).push(listener);
        }
        emit(event, payload) {
            if (this.events.has(event)) {
                this.events.get(event).forEach(listener => listener(payload));
            }
        }
    }

    /**
     * Manages the state history for undo/redo functionality.
     */
    class HistoryManager {
        constructor(limit) {
            this.limit = limit;
            this.history = [];
            this.pointer = -1;
            this.emitter = new EventEmitter();
        }
        
        add(state) {
            if (this.pointer < this.history.length - 1) {
                this.history.splice(this.pointer + 1);
            }
            this.history.push(state);
            if (this.history.length > this.limit) {
                this.history.shift();
            }
            this.pointer = this.history.length - 1;
            this.emitChange();
        }

        undo() {
            if (this.canUndo()) {
                this.pointer--;
                this.emitChange();
                return this.history[this.pointer];
            }
            return null;
        }

        redo() {
            if (this.canRedo()) {
                this.pointer++;
                this.emitChange();
                return this.history[this.pointer];
            }
            return null;
        }

        canUndo() { return this.pointer > 0; }
        canRedo() { return this.pointer < this.history.length - 1; }
        
        on(event, listener) { this.emitter.on(event, listener); }
        emitChange() { this.emitter.emit('change', { canUndo: this.canUndo(), canRedo: this.canRedo() }); }
        
        clear() {
            this.history = [];
            this.pointer = -1;
            this.emitChange();
        }
    }

    /**
     * Represents a node in the Binary Space Partitioning (BSP) tree.
     */
    class BSPNode {
        constructor(options = {}) {
            this.id = options.id || self.crypto.randomUUID();
            this.parent = options.parent || null;
            this.children = options.children || [];
            this.direction = options.direction || null;
            this.split = options.split || CONFIG.DEFAULT_SPLIT;
            this.element = options.element || null; 
            this.isPinned = options.isPinned || false;
            this.isCollapsed = options.isCollapsed || false;
            this.isMainContent = options.isMainContent || false;
            this.isToolbar = options.isToolbar || false;
        }

        isLeaf() { return this.children.length === 0; }

        getSibling() {
            if (!this.parent) return null;
            return this.parent.children.find(child => child !== this);
        }

        clone(parent = null) {
            const newChildren = [];
            const newInstance = new BSPNode({
                id: this.id,
                parent,
                direction: this.direction,
                split: this.split,
                isPinned: this.isPinned,
                isCollapsed: this.isCollapsed,
                isMainContent: this.isMainContent,
                isToolbar: this.isToolbar,
                children: newChildren,
                element: this.element // Keep reference to original element
            });
            newChildren.push(...this.children.map(c => c.clone(newInstance)));
            return newInstance;
        }

        toJSON() {
            const obj = {
                id: this.id,
                direction: this.direction,
                split: this.split,
                isPinned: this.isPinned,
                isCollapsed: this.isCollapsed,
                isMainContent: this.isMainContent,
                isToolbar: this.isToolbar,
                children: this.children.map(c => c.toJSON())
            };
            if (this.isLeaf()) obj.leaf = true;
            return obj;
        }

        static fromJSON(json, parent, panelElementsMap) {
            const node = new BSPNode({ ...json, parent });
            if (json.leaf) {
                node.element = panelElementsMap.get(json.id);
            } else {
                node.children = json.children.map(childJson => 
                    BSPNode.fromJSON(childJson, node, panelElementsMap)
                );
            }
            return node;
        }
    }

    /**
     * Manages the entire panel grid system.
     */
    class PanelManager {
        constructor(container) {
            this.container = container;
            this.panels = new Map();
            this.resizers = [];
            this.root = null;
            this.previewRoot = null;
            this.isPreviewMode = false;
            this.lastDragOverTarget = { panelId: null, zone: null };
            this.nextPanelNumber = 1;
            this.history = new HistoryManager(CONFIG.HISTORY_LIMIT);
            this.minSizeCache = new Map();
            this.markdownConverter = new showdown.Converter();
            this.markdownContent = new Map();
            this.alignmentGuides = [];
            this.globalClickHandler = null;

            this.handlePointerDown = this.handlePointerDown.bind(this);
            this.handlePointerMove = this.handlePointerMove.bind(this);
            this.handlePointerUp = this.handlePointerUp.bind(this);
            this.handleDragOver = this.handleDragOver.bind(this);
            this.updatePreviewLayout = this.updatePreviewLayout.bind(this);
        }

        init() {
            this.setupUI();
            // Load default layout instead of resetLayout
            this.loadLayout(DEFAULT_LAYOUT);
            this.setupEventListeners();
        }

        setupUI() {
            this.dom = {
                addPanelBtn: null,
                resetLayoutBtn: null,
                undoBtn: null,
                redoBtn: null,
            };
        }
        
        setupEventListeners() {
            this.container.addEventListener('pointerdown', this.handlePointerDown);
            window.addEventListener('resize', () => this.layout());
            
            // Add double-click event listener for markdown editing
            this.container.addEventListener('dblclick', this.handleDoubleClick.bind(this));
            
            // Menu drag functionality
            this.menuDragState = {
                isDragging: false,
                startMenuItem: null
            };
            
            // Bind menu drag handlers to preserve 'this' context
            this.handleMenuDrag = this.handleMenuDrag.bind(this);
            this.handleMenuDragEnd = this.handleMenuDragEnd.bind(this);
            
            if (this.dom.addPanelBtn) this.dom.addPanelBtn.addEventListener('click', () => this.addPanel());
            if (this.dom.resetLayoutBtn) this.dom.resetLayoutBtn.addEventListener('click', () => this.resetLayout());
            if (this.dom.undoBtn) this.dom.undoBtn.addEventListener('click', () => this.undo());
            if (this.dom.redoBtn) this.dom.redoBtn.addEventListener('click', () => this.redo());
            
            // Set up history change listener for undo/redo button states
            this.history.on('change', ({ canUndo, canRedo }) => {
                if (this.dom.undoBtn) this.dom.undoBtn.disabled = !canUndo;
                if (this.dom.redoBtn) this.dom.redoBtn.disabled = !canRedo;
                
                const headerUndoBtn = document.getElementById('header-undo-btn');
                const headerRedoBtn = document.getElementById('header-redo-btn');
                if (headerUndoBtn) headerUndoBtn.disabled = !canUndo;
                if (headerRedoBtn) headerRedoBtn.disabled = !canRedo;
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
                        e.preventDefault();
                        this.redo();
                    }
                }
            });
        }

        resetLayout() {
            // Load the predefined DEFAULT_LAYOUT
            this.loadLayout(DEFAULT_LAYOUT);
        }

        saveState(action) {
            const serializedTree = this.root.toJSON();
            const markdownData = Object.fromEntries(this.markdownContent);
            this.history.add({ action, tree: serializedTree, markdown: markdownData });
        }
        
        restoreState(state) {
            // TODO: This does not handle undoing panel creation/deletion correctly,
            // as the panel DOM elements may not exist in the current state.
            // It works for state changes on existing panels, like content edits.
            const panelElementsMap = new Map();
            this.panels.forEach(p => panelElementsMap.set(p.node.id, p.element));
            
            this.markdownContent = new Map(Object.entries(state.markdown || {}));
            this.root = BSPNode.fromJSON(state.tree, null, panelElementsMap);
            
            this.panels.clear();
            const syncPanels = (node) => {
                if (node.isLeaf()) {
                    this.panels.set(node.id, { node, element: node.element });
                    if (!node.isToolbar) {
                        const markdown = this.markdownContent.get(node.id) || '';
                        this.setPanelMarkdown(node.id, markdown);
                    }
                } else {
                    node.children.forEach(syncPanels);
                }
            };
            syncPanels(this.root);
            
            this.layout();
            
            const headerPanel = Array.from(this.panels.values()).find(p => p.element.classList.contains('header-panel'));
            if (headerPanel) {
                // Set up the file menu in the header for restore state
                const headerElement = headerPanel.element.querySelector('.panel-header');
                if (headerElement) {
                    headerElement.innerHTML = `
                        <div class="file-menu">
                            <span class="menu-item" data-menu="file">File</span>
                            <span class="menu-item" data-menu="edit">Edit</span>
                            <span class="menu-item" data-menu="view">View</span>
                            <span class="menu-item" data-menu="terminal">Terminal</span>
                            <span class="menu-item" data-menu="help">Help</span>
                        </div>
                        <div class="header-toolbar">
                            <button class="btn" data-action="add-panel" title="Add Panel">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                            </button>
                            <button class="btn" data-action="reset-layout" title="Reset Layout">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                            </button>
                            <button class="btn" data-action="undo" id="header-undo-btn" title="Undo (Ctrl+Z)" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                            </button>
                            <button class="btn" data-action="redo" id="header-redo-btn" title="Redo (Ctrl+Y)" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 14 5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                            </button>
                            <div class="toolbar-separator"></div>
                            <button class="btn" data-action="save-layout" title="Save Layout as JSON">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                            </button>
                            <button class="btn" data-action="load-layout" title="Load Layout from JSON">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M10 15l2 2 4-4"/></svg>
                            </button>
                        </div>
                    `;
                }
            }

            const actionBarPanel = Array.from(this.panels.values()).find(p => p.element.classList.contains('action-bar-panel'));
            if (actionBarPanel) {
                const actionBarContent = `
                    <div class="action-bar-content">
                        <div class="action-list">
                            <button class="action-item" data-action="new-document" title="New Document">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>
                            </button>
                            <button class="action-item" data-action="open-file" title="Open File">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                            </button>
                            <button class="action-item" data-action="save" title="Save">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                            </button>
                        </div>
                    </div>
                `;
                this.setPanelHtml(actionBarPanel.node.id, actionBarContent);
            }
        }
        
        undo() {
            const state = this.history.undo();
            if (state) this.restoreState(state);
        }

        redo() {
            const state = this.history.redo();
            if (state) this.restoreState(state);
        }

        layout(isPreview = false) {
            const tree = isPreview ? this.previewRoot : this.root;
            if (!tree) return;

            const computedStyle = getComputedStyle(this.container);
            const paddingLeft = parseFloat(computedStyle.paddingLeft);
            const paddingTop = parseFloat(computedStyle.paddingTop);
            const paddingRight = parseFloat(computedStyle.paddingRight);
            const paddingBottom = parseFloat(computedStyle.paddingBottom);

            this.minSizeCache.clear();
            
            if (!isPreview) {
                this.resizers.forEach(r => r.remove());
                this.resizers = [];
            }

            const layoutRecursive = (node, rect) => {
                node.rect = rect;

                if (node.isLeaf()) {
                    Object.assign(node.element.style, {
                        left: `${rect.x}px`, top: `${rect.y}px`,
                        width: `${rect.width}px`, height: `${rect.height}px`
                    });
                    if (!isPreview) {
                       this.updatePanelControls(node);
                    }
                    return;
                }

                const [child1, child2] = node.children;
                let rect1, rect2;

                if (node.direction === 'vertical') {
                    const availableWidth = rect.width - CONFIG.RESIZER_THICKNESS;
                    let width1, width2;
                    const child1Collapsed = child1.isLeaf() && child1.isCollapsed;
                    const child2Collapsed = child2.isLeaf() && child2.isCollapsed;
                    const child1Toolbar = child1.isLeaf() && child1.isToolbar;
                    const child2Toolbar = child2.isLeaf() && child2.isToolbar;

                    if (child1Collapsed || child1Toolbar) {
                        width1 = CONFIG.COLLAPSED_SIZE;
                        width2 = availableWidth - width1;
                    } else if (child2Collapsed || child2Toolbar) {
                        width2 = CONFIG.COLLAPSED_SIZE;
                        width1 = availableWidth - width2;
                    } else {
                        const minWidth1 = this.calculateMinimumWidth(child1);
                        const minWidth2 = this.calculateMinimumWidth(child2);
                        const totalMinWidth = minWidth1 + minWidth2;
                        if (totalMinWidth > availableWidth) {
                            node.split = (totalMinWidth > 0) ? (minWidth1 / totalMinWidth) : 0.5;
                        }

                        width1 = Math.max(minWidth1, availableWidth * node.split);
                        width2 = availableWidth - width1;
                        if (width2 < minWidth2) {
                            width2 = minWidth2;
                            width1 = availableWidth - width2;
                        }
                    }
                    if (availableWidth > 0) node.split = width1 / availableWidth;
                    
                    rect1 = { ...rect, width: width1 };
                    rect2 = { ...rect, x: rect.x + width1 + CONFIG.RESIZER_THICKNESS, width: width2 };

                    if (!isPreview) {
                        const resizerX = rect.x + width1;
                        const resizer = this.createResizer(node, resizerX, rect.y, CONFIG.RESIZER_THICKNESS, rect.height, 'vertical');
                        this.resizers.push(resizer);
                    }
                } else {
                    const availableHeight = rect.height - CONFIG.RESIZER_THICKNESS;
                    let height1, height2;
                    const child1Collapsed = child1.isLeaf() && child1.isCollapsed;
                    const child2Collapsed = child2.isLeaf() && child2.isCollapsed;
                    const child1Toolbar = child1.isLeaf() && child1.isToolbar;
                    const child2Toolbar = child2.isLeaf() && child2.isToolbar;

                    if (child1Collapsed || child1Toolbar) {
                        height1 = CONFIG.COLLAPSED_SIZE;
                        height2 = availableHeight - height1;
                    } else if (child2Collapsed || child2Toolbar) {
                        height2 = CONFIG.COLLAPSED_SIZE;
                        height1 = availableHeight - height2;
                    } else {
                        const minHeight1 = this.calculateMinimumHeight(child1);
                        const minHeight2 = this.calculateMinimumHeight(child2);
                        const totalMinHeight = minHeight1 + minHeight2;
                        if (totalMinHeight > availableHeight) {
                            node.split = (totalMinHeight > 0) ? (minHeight1 / totalMinHeight) : 0.5;
                        }

                        height1 = Math.max(minHeight1, availableHeight * node.split);
                        height2 = availableHeight - height1;
                        if (height2 < minHeight2) {
                            height2 = minHeight2;
                            height1 = availableHeight - height2;
                        }
                    }
                    if (availableHeight > 0) node.split = height1 / availableHeight;
                    
                    rect1 = { ...rect, height: height1 };
                    rect2 = { ...rect, y: rect.y + height1 + CONFIG.RESIZER_THICKNESS, height: height2 };
                    
                    if (!isPreview) {
                        const resizerY = rect.y + height1;
                        const resizer = this.createResizer(node, rect.x, resizerY, rect.width, CONFIG.RESIZER_THICKNESS, 'horizontal');
                        this.resizers.push(resizer);
                    }
                }

                layoutRecursive(child1, rect1);
                layoutRecursive(child2, rect2);
            };
            
            const containerRect = this.container.getBoundingClientRect();
            const layoutWidth = containerRect.width - paddingLeft - paddingRight;
            const layoutHeight = containerRect.height - paddingTop - paddingBottom;
            
            layoutRecursive(tree, { x: paddingLeft, y: paddingTop, width: layoutWidth, height: layoutHeight });
        }

        createPanelElement(panelNumber, customName = null) {
            const element = document.createElement('div');
            element.className = `panel ${CONFIG.PANEL_ANIMATION_CLASS}`;
            
            // Use custom name if provided, otherwise default to "Panel X"
            const panelTitle = customName || `Panel ${panelNumber}`;
            
            element.innerHTML = `
                <div class="panel-header">
                    <button class="panel-action-btn" data-action="pin" title="Pin Panel">
                        <svg class="icon-pin" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="8"/></svg>
                        <svg class="icon-pin-off" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="8"/></svg>
                    </button>
                    <span class="panel-title">${panelTitle}</span>
                    <div class="panel-actions">
                        <button class="panel-action-btn" data-action="collapse" title="Collapse Panel"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                        <button class="panel-action-btn" data-action="split-v" title="Split Vertically"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><line x1="12" y1="3" x2="12" y2="21"/></svg></button>
                        <button class="panel-action-btn" data-action="split-h" title="Split Horizontally"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><line x1="3" y1="12" x2="21" y2="12"/></svg></button>
                        <button class="panel-action-btn" data-action="close" title="Close Panel"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg></button>
                    </div>
                </div>
                <div class="panel-content"></div>`;
            
            element.addEventListener('animationend', () => element.classList.remove(CONFIG.PANEL_ANIMATION_CLASS), { once: true });
            this.container.appendChild(element);
            return element;
        }

        // Helper function to get custom panel names
        getCustomPanelName(panelNumber) {
            const customNames = {
                1: '', // Header panel will have empty title since we'll use menu in header
                3: 'Explorer', 
                5: 'Footer',
                6: 'Properties'
            };
            return customNames[panelNumber] || null;
        }

        createPanel() {
            const panelNumber = this.nextPanelNumber++;
            const customName = this.getCustomPanelName(panelNumber);
            const element = this.createPanelElement(panelNumber, customName);
            const id = `panel-${panelNumber}-${Date.now()}`;
            element.dataset.panelId = id;
            return { id, element };
        }
        
        addPanel() {
            let largestUnpinnedLeaf = null;
            let maxArea = -1;

            const findLargestLeaf = (node) => {
                if (node.isLeaf() && !node.isPinned) {
                    const area = node.rect.width * node.rect.height;
                    if (area > maxArea) {
                        maxArea = area;
                        largestUnpinnedLeaf = node;
                    }
                } else if (!node.isLeaf()) {
                    node.children.forEach(findLargestLeaf);
                }
            };

            findLargestLeaf(this.root);

            if (largestUnpinnedLeaf) {
                const targetNode = largestUnpinnedLeaf;
                const canSplitV = targetNode.rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
                const canSplitH = targetNode.rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;

                const isWider = targetNode.rect.width > targetNode.rect.height;

                if (isWider) {
                    // Prefer vertical split for wider panels
                    if (canSplitV) {
                        this.splitPanel(targetNode.id, 'vertical');
                    } else if (canSplitH) {
                        this.splitPanel(targetNode.id, 'horizontal');
                    }
                } else {
                    // Prefer horizontal split for taller or square panels
                    if (canSplitH) {
                        this.splitPanel(targetNode.id, 'horizontal');
                    } else if (canSplitV) {
                        this.splitPanel(targetNode.id, 'vertical');
                    }
                }
            }
        }
        
        splitPanel(targetId, direction, suppressLayout = false) {
            const target = this.panels.get(targetId);
            if (!target) return null;
            const { node: targetNode } = target;

            if (targetNode.rect) { // Only check if rect is available
                if (direction === 'vertical') {
                    const canSplitV = targetNode.rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
                    if (!canSplitV) return null;
                } else { // horizontal
                    const canSplitH = targetNode.rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;
                    if (!canSplitH) return null;
                }
            }

            const newPanel = this.createPanel();
            const newNode = new BSPNode({ id: newPanel.id, element: newPanel.element });
            this.panels.set(newPanel.id, { node: newNode, element: newPanel.element });
            
            const newParent = new BSPNode({
                parent: targetNode.parent,
                direction,
                children: [targetNode, newNode],
                split: 0.3 + Math.random() * 0.4
            });

            targetNode.parent = newParent;
            newNode.parent = newParent;

            if (this.root === targetNode) {
                this.root = newParent;
            } else {
                const oldParent = newParent.parent;
                if (!oldParent) return null; // Should not happen in a valid tree
                const targetIndex = oldParent.children.indexOf(targetNode);
                oldParent.children.splice(targetIndex, 1, newParent);
            }
            
            if (!suppressLayout) {
                this.layout();
                this.saveState(`Split ${direction}`);
            }
            return { oldNode: targetNode, newNode: newNode };
        }
        
        createRandomPattern(startNode, numSplits) {
            let leaves = [startNode];

            for (let i = 0; i < numSplits && leaves.length > 0; i++) {
                const leafIndex = Math.floor(Math.random() * leaves.length);
                const leafToSplit = leaves[leafIndex];
                leaves.splice(leafIndex, 1);

                const canSplitV = leafToSplit.rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
                const canSplitH = leafToSplit.rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;

                const possibleDirections = [];
                if (canSplitV) possibleDirections.push('vertical');
                if (canSplitH) possibleDirections.push('horizontal');

                if (possibleDirections.length === 0) continue;

                const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                
                const result = this.splitPanel(leafToSplit.id, direction, true);
                if (result) {
                    const { oldNode, newNode } = result;
                    
                    const parentRect = leafToSplit.rect;
                    const newParentNode = oldNode.parent;
                    let rect1, rect2;

                    if (direction === 'vertical') {
                        const availableWidth = parentRect.width - CONFIG.RESIZER_THICKNESS;
                        const width1 = availableWidth * newParentNode.split;
                        const width2 = availableWidth - width1;
                        rect1 = { ...parentRect, width: width1 };
                        rect2 = { ...parentRect, x: parentRect.x + width1 + CONFIG.RESIZER_THICKNESS, width: width2 };
                    } else {
                        const availableHeight = parentRect.height - CONFIG.RESIZER_THICKNESS;
                        const height1 = availableHeight * newParentNode.split;
                        const height2 = availableHeight - height1;
                        rect1 = { ...parentRect, height: height1 };
                        rect2 = { ...parentRect, y: parentRect.y + height1 + CONFIG.RESIZER_THICKNESS, height: height2 };
                    }
                    oldNode.rect = rect1;
                    newNode.rect = rect2;

                    leaves.push(oldNode, newNode);
                }
            }
        }

        closePanel(targetId) {
            const target = this.panels.get(targetId);
            if (!target || this.panels.size <= 1) return;
            const { node: targetNode } = target;

            const parent = targetNode.parent;
            const sibling = targetNode.getSibling();
            const grandparent = parent.parent;

            if (grandparent) {
                const parentIndex = grandparent.children.indexOf(parent);
                grandparent.children.splice(parentIndex, 1, sibling);
                sibling.parent = grandparent;
            } else {
                this.root = sibling;
                sibling.parent = null;
            }

            targetNode.element.remove();
            this.panels.delete(targetId);
            this.layout();
            this.saveState("Close Panel");
        }

        calculateMinimumHeight(node) {
            if (this.minSizeCache.has(node.id + '-h')) return this.minSizeCache.get(node.id + '-h');
            if (node.isLeaf()) {
                // Toolbar panels should never exceed header height
                if (node.isToolbar) {
                    return CONFIG.COLLAPSED_SIZE;
                }
                return CONFIG.PANEL_MIN_HEIGHT;
            }
            
            const [child1, child2] = node.children;
            const h1 = this.calculateMinimumHeight(child1);
            const h2 = this.calculateMinimumHeight(child2);
            
            const result = node.direction === 'horizontal' 
                ? h1 + h2 + CONFIG.RESIZER_THICKNESS 
                : Math.max(h1, h2);
            
            this.minSizeCache.set(node.id + '-h', result);
            return result;
        }

        calculateMinimumWidth(node) {
            if (this.minSizeCache.has(node.id + '-w')) return this.minSizeCache.get(node.id + '-w');
            if (node.isLeaf()) {
                // Toolbar panels should never exceed header width
                if (node.isToolbar) {
                    return CONFIG.COLLAPSED_SIZE;
                }
                return CONFIG.PANEL_MIN_WIDTH;
            }
            
            const [child1, child2] = node.children;
            const w1 = this.calculateMinimumWidth(child1);
            const w2 = this.calculateMinimumWidth(child2);
            
            const result = node.direction === 'vertical' 
                ? w1 + w2 + CONFIG.RESIZER_THICKNESS 
                : Math.max(w1, w2);

            this.minSizeCache.set(node.id + '-w', result);
            return result;
        }
        
        handlePointerDown(e) {
            const resizer = e.target.closest('.panel-resizer');
            const header = e.target.closest('.panel-header');
            const actionBtn = e.target.closest('.panel-action-btn');

            if (actionBtn) {
                this.handleActionClick(actionBtn);
                return;
            }

            // Check for toolbar buttons (.btn) in both content and header areas
            const toolbarBtn = e.target.closest('button.btn');
            if (toolbarBtn) {
                this.handleContentButtonClick(toolbarBtn);
                return;
            }
            
            // Check for file menu items
            const menuItem = e.target.closest('.menu-item');
            if (menuItem) {
                this.handleMenuPointerDown(menuItem, e);
                return;
            }
            
            if (resizer && !resizer.classList.contains('is-disabled')) {
                const nodeId = resizer.dataset.nodeId;
                const targetNode = this._findNodeById(this.root, nodeId);
                if (!targetNode) return;
                this.activeDrag = { type: 'resize', resizer, target: targetNode };
            } else if (header) {
                const targetNode = this.findNodeByElement(header.parentElement);
                if (targetNode && !targetNode.isPinned) {
                    this.activeDrag = { type: 'move', header, target: targetNode };
                }
            } else if (e.target.closest('.panel-content')) {
                return; // Clicks on content should not proceed to drag logic
            }
            
            if (!this.activeDrag) return;

            e.preventDefault();
            this.activeDrag.startX = e.clientX;
            this.activeDrag.startY = e.clientY;
            
            this.container.classList.add('no-transition');
            document.body.style.cursor = this.activeDrag.type === 'resize' ? getComputedStyle(resizer).cursor : 'grabbing';

            window.addEventListener('pointermove', this.handlePointerMove);
            window.addEventListener('pointerup', this.handlePointerUp, { once: true });
        }
        
        handleMenuPointerDown(menuItem, e) {
            // Start menu drag tracking
            this.menuDragState.isDragging = true;
            this.menuDragState.startMenuItem = menuItem;
            
            // Add CSS class to prevent sticky hover states
            document.body.classList.add('menu-dragging');
            
            // Set up menu drag event listeners
            document.addEventListener('pointermove', this.handleMenuDrag);
            document.addEventListener('pointerup', this.handleMenuDragEnd, { once: true });
            
            // Handle the initial click
            this.handleMenuClick(menuItem);
        }
        
        handleMenuDrag(e) {
            if (!this.menuDragState.isDragging) return;
            
            const currentMenuItem = e.target.closest('.menu-item');
            
            // If we've moved to a different menu item or away from menu items entirely
            if (currentMenuItem !== this.menuDragState.startMenuItem) {
                // Clear visual state from previous menu item
                if (this.menuDragState.startMenuItem) {
                    this.menuDragState.startMenuItem.classList.remove('menu-open');
                }
                
                // If we're over a new menu item, switch to it
                if (currentMenuItem) {
                    this.handleMenuClick(currentMenuItem);
                    this.menuDragState.startMenuItem = currentMenuItem;
                } else {
                    // Mouse is not over any menu item, close all dropdowns
                    this.closeAllDropdowns();
                    this.menuDragState.startMenuItem = null;
                }
            }
        }
        
        handleMenuDragEnd(e) {
            // Remove CSS class that prevents sticky hover states
            document.body.classList.remove('menu-dragging');
            
            // Clean up any remaining visual states
            const allMenuItems = document.querySelectorAll('.menu-item');
            allMenuItems.forEach(item => {
                // Remove any lingering hover or active states that might be stuck
                item.blur();
            });
            
            this.menuDragState.isDragging = false;
            this.menuDragState.startMenuItem = null;
            document.removeEventListener('pointermove', this.handleMenuDrag);
        }

        handleMenuClick(menuItem) {
            const menuType = menuItem.dataset.menu;
            
            // Check if ANY dropdown is currently open
            const anyDropdownOpen = document.querySelector('.dropdown-menu.show');
            const thisMenuOpen = menuItem.classList.contains('menu-open');
            
            // If we're in drag mode, always switch to the new menu
            if (this.menuDragState.isDragging) {
                this.closeAllDropdowns();
                this.showDropdownMenu(menuItem, menuType);
                return;
            }
            
            // Normal click behavior
            // Always close all dropdowns first
            this.closeAllDropdowns();
            
            // If this specific menu wasn't open, open it
            // (If any other menu was open, we still want to open this one)
            if (!thisMenuOpen) {
                this.showDropdownMenu(menuItem, menuType);
            }
        }
        
        closeAllDropdowns() {
            // Remove the global click handler if it exists
            if (this.globalClickHandler) {
                document.removeEventListener('click', this.globalClickHandler);
                this.globalClickHandler = null;
            }
            
            // Ensure menu-dragging class is removed
            document.body.classList.remove('menu-dragging');
            
            const existingDropdowns = document.querySelectorAll('.dropdown-menu');
            const openMenuItems = document.querySelectorAll('.menu-item.menu-open');
            
            existingDropdowns.forEach(dropdown => {
                dropdown.classList.remove('show');
                dropdown.remove();
            });
            
            openMenuItems.forEach(menuItem => {
                menuItem.classList.remove('menu-open');
                delete menuItem.dataset.dropdownId;
            });
        }
        
        showDropdownMenu(menuItem, menuType) {
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown-menu';
            
            const menuContent = this.getMenuContent(menuType);
            dropdown.innerHTML = menuContent;
            
            // Append to body instead of menu item to avoid stacking context issues
            document.body.appendChild(dropdown);
            
            // Calculate position relative to viewport
            const menuRect = menuItem.getBoundingClientRect();
            dropdown.style.position = 'fixed';
            dropdown.style.top = `${menuRect.bottom}px`;
            dropdown.style.left = `${menuRect.left}px`;
            
            // Mark menu item as open
            menuItem.classList.add('menu-open');
            
            // Show dropdown with animation
            requestAnimationFrame(() => {
                dropdown.classList.add('show');
            });
            
            // Add click handlers for dropdown items
            this.setupDropdownHandlers(dropdown);
            
            // Store reference for cleanup
            const dropdownId = Date.now().toString();
            menuItem.dataset.dropdownId = dropdownId;
            dropdown.dataset.dropdownId = dropdownId;
            
            // Set up global click handler to close dropdown when clicking outside
            this.globalClickHandler = (e) => {
                // Don't close if we're in menu drag mode
                if (this.menuDragState.isDragging) {
                    return;
                }
                // Don't close if clicking on a menu item or inside the dropdown
                if (e.target.closest('.menu-item') || e.target.closest('.dropdown-menu')) {
                    return;
                }
                this.closeAllDropdowns();
            };
            
            // Add the global click handler with a small delay to avoid immediate triggering
            setTimeout(() => {
                document.addEventListener('click', this.globalClickHandler);
            }, 50);
        }
        
                 getMenuContent(menuType) {
             switch(menuType) {
                 case 'file':
                     return `
                         <button class="dropdown-item" data-action="new-file">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>
                             New File
                             <span class="shortcut">Ctrl+N</span>
                         </button>
                         <button class="dropdown-item" data-action="open-file">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                             Open File
                             <span class="shortcut">Ctrl+O</span>
                         </button>
                         <div class="dropdown-separator"></div>
                         <button class="dropdown-item" data-action="save-file">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                             Save
                             <span class="shortcut">Ctrl+S</span>
                         </button>
                         <button class="dropdown-item" data-action="save-as">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                             Save As...
                             <span class="shortcut">Ctrl+Shift+S</span>
                         </button>
                         <div class="dropdown-separator"></div>
                         <button class="dropdown-item" data-action="save-layout">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3z"/><path d="M12 8v8"/><path d="M8 12h8"/></svg>
                             Save Layout
                         </button>
                         <button class="dropdown-item" data-action="load-layout">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3z"/><path d="M8 8h8v8H8z"/></svg>
                             Load Layout
                         </button>
                     `;
                     
                 case 'edit':
                     return `
                         <button class="dropdown-item" data-action="undo">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                             Undo
                             <span class="shortcut">Ctrl+Z</span>
                         </button>
                         <button class="dropdown-item" data-action="redo">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 14 5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                             Redo
                             <span class="shortcut">Ctrl+Y</span>
                         </button>
                         <div class="dropdown-separator"></div>
                         <button class="dropdown-item" data-action="cut">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"/><path d="M8.12 8.12L12 12"/><path d="M20 4L8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8L20 20"/></svg>
                             Cut
                             <span class="shortcut">Ctrl+X</span>
                         </button>
                         <button class="dropdown-item" data-action="copy">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
                             Copy
                             <span class="shortcut">Ctrl+C</span>
                         </button>
                         <button class="dropdown-item" data-action="paste">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/></svg>
                             Paste
                             <span class="shortcut">Ctrl+V</span>
                         </button>
                     `;
                     
                 case 'view':
                     return `
                         <button class="dropdown-item" data-action="add-panel">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                             Add Panel
                         </button>
                         <button class="dropdown-item" data-action="reset-layout">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                             Reset Layout
                         </button>
                         <div class="dropdown-separator"></div>
                         <button class="dropdown-item" data-action="toggle-explorer">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2z"/></svg>
                             Toggle Explorer
                         </button>
                         <button class="dropdown-item" data-action="toggle-properties">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                             Toggle Properties
                         </button>
                     `;
                     
                 case 'terminal':
                     return `
                         <button class="dropdown-item" data-action="new-terminal">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 17 10 11 4 5"/><line x1="12" x2="20" y1="19" y2="19"/></svg>
                             New Terminal
                             <span class="shortcut">Ctrl+\`</span>
                         </button>
                         <button class="dropdown-item" data-action="toggle-terminal">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="7" x2="7" y1="9" y2="15"/><line x1="17" x2="17" y1="9" y2="15"/></svg>
                             Toggle Terminal
                         </button>
                         <div class="dropdown-separator"></div>
                         <button class="dropdown-item" data-action="clear-terminal">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                             Clear Terminal
                         </button>
                     `;
                     
                 case 'help':
                     return `
                         <button class="dropdown-item" data-action="shortcuts">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="M6 8h.001"/><path d="M10 8h.001"/><path d="M14 8h.001"/><path d="M18 8h.001"/><path d="M8 12h.001"/><path d="M12 12h.001"/><path d="M16 12h.001"/><path d="M7 16h10"/></svg>
                             Keyboard Shortcuts
                             <span class="shortcut">Ctrl+/</span>
                         </button>
                         <button class="dropdown-item" data-action="documentation">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                             Documentation
                         </button>
                         <div class="dropdown-separator"></div>
                         <button class="dropdown-item" data-action="about">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                             About FileUI
                         </button>
                     `;
                     
                 default:
                     return '<button class="dropdown-item">No items available</button>';
             }
         }
        
        setupDropdownHandlers(dropdown) {
            const items = dropdown.querySelectorAll('.dropdown-item[data-action]');
            items.forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const action = item.dataset.action;
                    this.handleDropdownAction(action);
                    this.closeAllDropdowns();
                });
            });
        }
        
        handleDropdownAction(action) {
            // Handle dropdown menu actions
            switch(action) {
                // File menu actions
                case 'new-file':
                    console.log('New file');
                    // TODO: Implement new file functionality
                    break;
                case 'open-file':
                    console.log('Open file');
                    // TODO: Implement open file functionality
                    break;
                case 'save-file':
                    console.log('Save file');
                    // TODO: Implement save file functionality
                    break;
                case 'save-as':
                    console.log('Save as');
                    // TODO: Implement save as functionality
                    break;
                case 'save-layout':
                    this.saveLayoutToFile();
                    break;
                case 'load-layout':
                    this.loadLayoutFromFile();
                    break;
                    
                // Edit menu actions
                case 'undo':
                    this.undo();
                    break;
                case 'redo':
                    this.redo();
                    break;
                case 'cut':
                    console.log('Cut');
                    // TODO: Implement cut functionality
                    break;
                case 'copy':
                    console.log('Copy');
                    // TODO: Implement copy functionality
                    break;
                case 'paste':
                    console.log('Paste');
                    // TODO: Implement paste functionality
                    break;
                    
                // View menu actions
                case 'add-panel':
                    this.addPanel();
                    break;
                case 'reset-layout':
                    this.resetLayout();
                    break;
                case 'toggle-explorer':
                    console.log('Toggle explorer');
                    // TODO: Implement toggle explorer functionality
                    break;
                case 'toggle-properties':
                    console.log('Toggle properties');
                    // TODO: Implement toggle properties functionality
                    break;
                    
                // Terminal menu actions
                case 'new-terminal':
                    console.log('New terminal');
                    // TODO: Implement new terminal functionality
                    break;
                case 'toggle-terminal':
                    console.log('Toggle terminal');
                    // TODO: Implement toggle terminal functionality
                    break;
                case 'clear-terminal':
                    console.log('Clear terminal');
                    // TODO: Implement clear terminal functionality
                    break;
                    
                // Help menu actions
                case 'shortcuts':
                    console.log('Show shortcuts');
                    // TODO: Implement shortcuts modal
                    break;
                case 'documentation':
                    console.log('Show documentation');
                    // TODO: Implement documentation
                    break;
                case 'about':
                    console.log('Show about');
                    // TODO: Implement about modal
                    break;
                    
                default:
                    console.log(`Unknown action: ${action}`);
            }
        }
        
        showFileMenu(menuItem) {
            // Method kept for backward compatibility but now handled by showDropdownMenu
            this.showDropdownMenu(menuItem, 'file');
        }
        
        showEditMenu(menuItem) {
            // Method kept for backward compatibility but now handled by showDropdownMenu
            this.showDropdownMenu(menuItem, 'edit');
        }
        
        showViewMenu(menuItem) {
            // Method kept for backward compatibility but now handled by showDropdownMenu
            this.showDropdownMenu(menuItem, 'view');
        }
        
        showTerminalMenu(menuItem) {
            // Method kept for backward compatibility but now handled by showDropdownMenu
            this.showDropdownMenu(menuItem, 'terminal');
        }
        
        showHelpMenu(menuItem) {
            // Method kept for backward compatibility but now handled by showDropdownMenu
            this.showDropdownMenu(menuItem, 'help');
        }
        
        handlePointerMove(e) {
            if (!this.activeDrag) return;

            if (this.activeDrag.type === 'resize') {
                this.handleResize(e);
            } else if (this.activeDrag.type === 'move' && !this.activeDrag.isDragging) {
                const dx = e.clientX - this.activeDrag.startX;
                const dy = e.clientY - this.activeDrag.startY;
                if (Math.hypot(dx, dy) > 5) {
                    this.initDrag();
                }
            }
        }
        
        handlePointerUp() {
            if (this.activeDrag?.isDragging) {
                this.handleDrop();
            } else if (this.activeDrag?.type === 'resize') {
                this.saveState("Resize");
            }
            
            const wasDragging = this.activeDrag?.isDragging;

            this.exitPreviewMode();

            this.container.classList.remove('no-transition');
            document.body.style.cursor = '';
            this.activeDrag = null;
            window.removeEventListener('pointermove', this.handlePointerMove);

            if (wasDragging) {
                this.layout();
            }
        }

        handleActionClick(button) {
            const action = button.dataset.action;
            const panelId = button.closest('.panel')?.dataset.panelId;
            if (!panelId) return;

            switch(action) {
                case 'pin': this.togglePin(panelId); break;
                case 'collapse': this.toggleCollapse(panelId); break;
                case 'split-v': this.splitPanel(panelId, 'vertical'); break;
                case 'split-h': this.splitPanel(panelId, 'horizontal'); break;
                case 'close': this.closePanel(panelId); break;
            }
        }
        
        handleContentButtonClick(button) {
            const action = button.dataset.action;
            const panelId = button.closest('.panel')?.dataset.panelId;

            const findMainPanel = () => {
                for (const panel of this.panels.values()) {
                    if (panel.node.isMainContent) return panel;
                }
                return null;
            };
            
            switch (action) {
                // Global App Actions
                case 'add-panel': this.addPanel(); break;
                case 'reset-layout': this.resetLayout(); break;
                case 'undo': this.undo(); break;
                case 'redo': this.redo(); break;
                case 'save-layout': this.saveLayoutToFile(); break;
                case 'load-layout': this.loadLayoutFromFile(); break;

                // Markdown Content Actions
                case 'add-h1':
                case 'add-bold':
                case 'add-italic':
                    const mainPanel = findMainPanel();
                    if (!mainPanel) {
                        alert("No main content panel found!");
                        return;
                    }
                    const currentMarkdown = this.markdownContent.get(mainPanel.node.id) || '';
                    let newMarkdown = currentMarkdown;
                    
                    if (action === 'add-h1') newMarkdown += '\n\n# New Header';
                    else if (action === 'add-bold') newMarkdown += '\n\n**Bold Text**';
                    else if (action === 'add-italic') newMarkdown += '\n\n*Italic Text*';

                    if (newMarkdown !== currentMarkdown) {
                        this.setPanelMarkdown(mainPanel.node.id, newMarkdown);
                        this.saveState("Edit Content");
                    }
                    break;

                // Test Action
                case 'test-alert':
                    alert(`Button clicked in panel: ${panelId}`);
                    break;
            }
        }
        
        handleResize(e) {
            const { target: node } = this.activeDrag;
            if (!node || node.isLeaf()) return;
            
            const parentRect = node.rect;
            if (node.direction === 'vertical') {
                const newSplit = (e.clientX - parentRect.x) / (parentRect.width - CONFIG.RESIZER_THICKNESS);
                const [child1, child2] = node.children;
                const availableWidth = parentRect.width - CONFIG.RESIZER_THICKNESS;
                let width1 = newSplit * availableWidth;
                let width2 = availableWidth - width1;
                
                // Constrain toolbar panels to collapsed size
                if (child1.isLeaf() && child1.isToolbar) {
                    width1 = CONFIG.COLLAPSED_SIZE;
                    width2 = availableWidth - width1;
                } else if (child2.isLeaf() && child2.isToolbar) {
                    width2 = CONFIG.COLLAPSED_SIZE;
                    width1 = availableWidth - width2;
                } else {
                    // Drag-to-collapse logic for non-toolbar panels
                    if (child1.isLeaf() && child1.isPinned) {
                        if (!child1.isCollapsed && width1 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                        else if (child1.isCollapsed && width1 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                    }
                    if (child2.isLeaf() && child2.isPinned) {
                        if (!child2.isCollapsed && width2 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                        else if (child2.isCollapsed && width2 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                    }
                }
                
                // Update split based on actual widths
                node.split = width1 / availableWidth;

            } else { // Horizontal resize
                const newSplit = (e.clientY - parentRect.y) / (parentRect.height - CONFIG.RESIZER_THICKNESS);
                const [child1, child2] = node.children;
                const availableHeight = parentRect.height - CONFIG.RESIZER_THICKNESS;
                let height1 = newSplit * availableHeight;
                let height2 = availableHeight - height1;

                // Constrain toolbar panels to collapsed size
                if (child1.isLeaf() && child1.isToolbar) {
                    height1 = CONFIG.COLLAPSED_SIZE;
                    height2 = availableHeight - height1;
                } else if (child2.isLeaf() && child2.isToolbar) {
                    height2 = CONFIG.COLLAPSED_SIZE;
                    height1 = availableHeight - height2;
                } else {
                    // Drag-to-collapse logic for non-toolbar panels
                    if (child1.isLeaf() && child1.isPinned) {
                        if (!child1.isCollapsed && height1 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                        else if (child1.isCollapsed && height1 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                    }
                    if (child2.isLeaf() && child2.isPinned) {
                        if (!child2.isCollapsed && height2 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                        else if (child2.isCollapsed && height2 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                    }
                }

                // Update split based on actual heights
                node.split = height1 / availableHeight;
            }
            this.layout();
        }

        initDrag() {
            this.activeDrag.isDragging = true;
            const draggedElement = this.activeDrag.target.element;
            this.enterPreviewMode(draggedElement);
            this.container.addEventListener('pointermove', this.handleDragOver);

            ['horizontal', 'horizontal', 'vertical', 'vertical'].forEach(direction => {
                const guide = document.createElement('div');
                guide.className = `alignment-guide ${direction}`;
                this.container.appendChild(guide);
                this.alignmentGuides.push(guide);
            });
        }
        
        handleDragOver(e) {
            if (!this.activeDrag?.isDragging) return;
            
            const containerRect = this.container.getBoundingClientRect();
            const relativeX = e.clientX - containerRect.left;
            const relativeY = e.clientY - containerRect.top;
            
            let targetPanel = null;
            let dropZone = null;
            
            const findTarget = (node) => {
                if (!node || targetPanel) return;
                if (node.isLeaf()) {
                    if (node.isPinned || node.element === this.activeDrag.target.element) return;
                    const rect = node.rect;
                    if (relativeX >= rect.x && relativeX <= rect.x + rect.width &&
                        relativeY >= rect.y && relativeY <= rect.y + rect.height) {
                            
                        targetPanel = node.element;
                        const x = relativeX - rect.x;
                        const y = relativeY - rect.y;
                        const w = rect.width;
                        const h = rect.height;

                        const distTop = y;
                        const distBottom = h - y;
                        const distLeft = x;
                        const distRight = w - x;

                        const minDist = Math.min(distTop, distBottom, distLeft, distRight);

                        if (minDist === distTop) {
                            dropZone = 'top';
                        } else if (minDist === distBottom) {
                            dropZone = 'bottom';
                        } else if (minDist === distLeft) {
                            dropZone = 'left';
                        } else {
                            dropZone = 'right';
                        }
                    }
                } else {
                    node.children.forEach(findTarget);
                }
            };
            findTarget(this.root);

            const hasChangedTarget = this.lastDragOverTarget.panelId !== (targetPanel?.dataset.panelId || null) || this.lastDragOverTarget.zone !== dropZone;

            if (targetPanel && dropZone && hasChangedTarget) {
                this.lastDragOverTarget = { panelId: targetPanel.dataset.panelId, zone: dropZone };
                this.activeDrag.currentTargetPanel = targetPanel;
                this.activeDrag.currentDropZone = dropZone;
                requestAnimationFrame(this.updatePreviewLayout);
            }

            this.layout(true);
        }
        
        updatePreviewLayout() {
            if (!this.isPreviewMode) return;
            
            this.previewRoot = this.root.clone();

            const { target, currentTargetPanel, currentDropZone } = this.activeDrag;
            if (currentTargetPanel && currentDropZone) {
                this.previewRoot = this._performMove(this.previewRoot, target.id, currentTargetPanel.dataset.panelId, currentDropZone);
            }
            
            this.layout(true);
        }

        _findNodeById(node, nodeId) {
            if (node.id === nodeId) return node;
            if (node.isLeaf()) return null;

            for (const child of node.children) {
                const found = this._findNodeById(child, nodeId);
                if (found) return found;
            }
            return null;
        }

        _isSubtreeFullyPinned(node) {
            if (node.isLeaf()) {
                return node.isPinned;
            }
            return node.children.every(child => this._isSubtreeFullyPinned(child));
        }

        _findLeafNodeById(tree, panelId) {
            if (tree.isLeaf()) {
                return tree.id === panelId ? tree : null;
            }
            for (const child of tree.children) {
                const found = this._findLeafNodeById(child, panelId);
                if (found) return found;
            }
            return null;
        }

        _performMove(tree, draggedId, targetId, zone) {
            if (draggedId === targetId) return tree;

            const draggedNode = this._findLeafNodeById(tree, draggedId);
            const targetNode = this._findLeafNodeById(tree, targetId);
            
            if (!draggedNode || !targetNode) return tree;

            // Detach dragged node
            const draggedParent = draggedNode.parent;
            if (draggedParent) {
                const sibling = draggedNode.getSibling();
                const grandparent = draggedParent.parent;
                if (grandparent) {
                    const parentIndex = grandparent.children.indexOf(draggedParent);
                    grandparent.children.splice(parentIndex, 1, sibling);
                    sibling.parent = grandparent;
                } else {
                    tree = sibling;
                    sibling.parent = null;
                }
            } else { return tree; } // Should not happen if tree is valid

            // Attach dragged node to target
            const targetParent = targetNode.parent;
            const direction = (zone === 'left' || zone === 'right') ? 'vertical' : 'horizontal';
            const children = (zone === 'left' || zone === 'top') ? [draggedNode, targetNode] : [targetNode, draggedNode];
            const newSplitNode = new BSPNode({ parent: targetParent, direction, children });

            draggedNode.parent = newSplitNode;
            targetNode.parent = newSplitNode;

            if (targetParent) {
                const targetIndex = targetParent.children.indexOf(targetNode);
                targetParent.children.splice(targetIndex, 1, newSplitNode);
            } else {
                tree = newSplitNode;
            }
            return tree;
        }

        enterPreviewMode(draggedElement) {
            this.isPreviewMode = true;
            this.previewRoot = this.root.clone();
            draggedElement.classList.add('is-dragging');
            this.container.classList.add('preview-mode');
            this.layout(true);
        }

        exitPreviewMode() {
            if (!this.isPreviewMode) return;
            
            this.alignmentGuides.forEach(guide => guide.remove());
            this.alignmentGuides = [];
            
            const draggedElement = this.activeDrag?.target.element;
            if (draggedElement) {
                draggedElement.classList.remove('is-dragging');
            }

            this.container.classList.remove('preview-mode');
            this.isPreviewMode = false;
            this.previewRoot = null;
            this.lastDragOverTarget = { panelId: null, zone: null };
            
            this.container.removeEventListener('pointermove', this.handleDragOver);
            this.saveState("Move Panel");
        }
        
        handleDrop() {
            const { currentTargetPanel, currentDropZone } = this.activeDrag;
            
            if (currentTargetPanel && currentDropZone) {
                this.root = this.previewRoot;

                this.panels.clear();
                const sync = (node) => {
                    if (node.isLeaf()) {
                        this.panels.set(node.id, { node, element: node.element });
                    } else {
                        node.children.forEach(sync);
                    }
                };
                sync(this.root);
                
                this.saveState("Move Panel");
            }
        }
        
        findNodeByElement(element) {
            const panelId = element.dataset.panelId;
            return this.panels.get(panelId)?.node;
        }

        createResizer(node, x, y, width, height, direction) {
            const resizer = document.createElement('div');
            resizer.className = `panel-resizer ${direction}`;
            resizer.dataset.nodeId = node.id;

            const [child1, child2] = node.children;
            const child1Pinned = this._isSubtreeFullyPinned(child1);
            const child2Pinned = this._isSubtreeFullyPinned(child2);
            const child1Collapsed = child1.isLeaf() && child1.isCollapsed;
            const child2Collapsed = child2.isLeaf() && child2.isCollapsed;
            const child1Toolbar = child1.isLeaf() && child1.isToolbar;
            const child2Toolbar = child2.isLeaf() && child2.isToolbar;

            if ((child1Pinned && child2Pinned) || child1Collapsed || child2Collapsed || child1Toolbar || child2Toolbar) {
                resizer.classList.add('is-disabled');
            }

            Object.assign(resizer.style, {
                left: `${x}px`, top: `${y}px`,
                width: `${width}px`, height: `${height}px`
            });
            this.container.appendChild(resizer);
            return resizer;
        }
        
        updatePanelControls(node) {
            if (!node.isLeaf()) return;
            const { element, rect } = node;

            const canSplitV = rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
            const canSplitH = rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;

            element.classList.toggle('is-pinned', node.isPinned);
            element.classList.toggle('is-collapsed', node.isCollapsed);
            element.classList.toggle('is-toolbar', node.isToolbar);

            // Add classes for collapse direction
            if (node.isCollapsed) {
                if (node.parent?.direction === 'horizontal') {
                    element.classList.add('is-collapsed-horizontally');
                    element.classList.remove('is-collapsed-vertically');
                } else { // 'vertical'
                    element.classList.add('is-collapsed-vertically');
                    element.classList.remove('is-collapsed-horizontally');
                }
            } else {
                element.classList.remove('is-collapsed-horizontally', 'is-collapsed-vertically');
            }

            // Handle pin button visibility - should be hidden for toolbar panels
            const pinBtn = element.querySelector('[data-action="pin"]');
            if (pinBtn) {
                if (node.isToolbar) {
                    pinBtn.style.display = 'none';
                } else {
                    pinBtn.style.display = 'inline-flex';
                }
            }

            const collapseBtn = element.querySelector('[data-action="collapse"]');
            if (collapseBtn) {
                const isCollapsible = node.isPinned && !node.isToolbar;
                collapseBtn.style.display = isCollapsible ? 'flex' : 'none';
            }

            const splitVBtn = element.querySelector('[data-action="split-v"]');
            if(splitVBtn) {
                splitVBtn.style.display = (node.isPinned || node.isToolbar) ? 'none' : 'flex';
                splitVBtn.disabled = !canSplitV || node.isCollapsed;
            }

            const splitHBtn = element.querySelector('[data-action="split-h"]');
            if(splitHBtn) {
                splitHBtn.style.display = (node.isPinned || node.isToolbar) ? 'none' : 'flex';
                splitHBtn.disabled = !canSplitH || node.isCollapsed;
            }
            
            const closeBtn = element.querySelector('[data-action="close"]');
            if(closeBtn) {
                closeBtn.style.display = (node.isPinned || node.isToolbar) ? 'none' : 'flex';
                closeBtn.disabled = (this.panels.size <= 1);
            }
        }

        togglePin(panelId) {
            const panel = this.panels.get(panelId);
            if (!panel) return;
            const { node } = panel;
            
            node.isPinned = !node.isPinned;
            // A panel cannot be both collapsed and unpinned
            if (!node.isPinned && node.isCollapsed) {
                node.isCollapsed = false;
            }
            this.layout(); // Recalculate layout to update resizer states
            this.saveState(`Pin panel ${node.isPinned ? 'on' : 'off'}`);
        }

        toggleCollapse(panelId) {
            const panel = this.panels.get(panelId);
            if (!panel || !panel.node.isPinned) return;
            const { node, element } = panel;
            
            node.isCollapsed = !node.isCollapsed;

            // Move action buttons for toolbar panels on collapse/expand
            if (node.isToolbar) {
                const header = element.querySelector('.panel-header');
                const content = element.querySelector('.panel-content');
                const toolbarContent = element.querySelector('.markdown-toolbar, .action-list');

                if (toolbarContent && header && content) {
                    if (node.isCollapsed) {
                        header.appendChild(toolbarContent);
                    } else {
                        content.appendChild(toolbarContent);
                    }
                }
            }
            
            this.layout();
            this.saveState(`Collapse panel ${node.isCollapsed ? 'on' : 'off'}`);
        }

        setPanelMarkdown(panelId, markdown) {
            const panel = this.panels.get(panelId);
            if (!panel) return;

            // Don't allow markdown content on toolbar panels
            if (panel.node.isToolbar) return;

            this.markdownContent.set(panelId, markdown);
            this.setPanelHtml(panelId, this.markdownConverter.makeHtml(markdown));
        }

        setPanelHtml(panelId, html) {
            const panel = this.panels.get(panelId);
            if (!panel) return;
            const contentArea = panel.element.querySelector('.panel-content');
            if (contentArea) {
                contentArea.innerHTML = html;
            }
        }

        updateAlignmentGuides(rect) {
            if (this.alignmentGuides.length < 4) return;
            const [topGuide, bottomGuide, leftGuide, rightGuide] = this.alignmentGuides;

            topGuide.style.transform = `translateY(${rect.y}px)`;
            bottomGuide.style.transform = `translateY(${rect.y + rect.height}px)`;
            leftGuide.style.transform = `translateX(${rect.x}px)`;
            rightGuide.style.transform = `translateX(${rect.x + rect.width}px)`;
        }

        handleDoubleClick(e) {
            // Check if double-click is on panel content (not header, resizer, or buttons)
            const panelContent = e.target.closest('.panel-content');
            if (!panelContent) return;
            
            // Don't edit if clicking on buttons or interactive elements
            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('input')) {
                return;
            }
            
            const panel = panelContent.closest('.panel');
            if (!panel) return;
            
            const panelId = panel.dataset.panelId;
            if (!panelId) return;
            
            // Skip toolbar panels (header and action bar)
            const panelNode = this.panels.get(panelId)?.node;
            if (panelNode?.isToolbar) return;
            
            this.startMarkdownEdit(panelId, panelContent);
        }

        startMarkdownEdit(panelId, contentElement) {
            const currentMarkdown = this.markdownContent.get(panelId) || '';
            const panel = contentElement.closest('.panel');
            
            // Create textarea for editing
            const textarea = document.createElement('textarea');
            textarea.className = 'markdown-editor';
            textarea.value = currentMarkdown;
            textarea.placeholder = 'Enter markdown content...';
            
            // Style the textarea
            Object.assign(textarea.style, {
                width: '100%',
                height: '100%',
                border: 'none',
                outline: 'none',
                resize: 'none',
                fontFamily: 'inherit',
                fontSize: 'inherit',
                lineHeight: '1.5',
                padding: '10px',
                backgroundColor: 'var(--panel-bg)',
                color: 'var(--text-color)',
                boxSizing: 'border-box'
            });
            
            // Replace content with editor
            contentElement.innerHTML = '';
            contentElement.appendChild(textarea);
            
            // Focus and select all text
            textarea.focus();
            textarea.select();
            
            // Handle save
            const handleSave = () => {
                const newMarkdown = textarea.value;
                this.setPanelMarkdown(panelId, newMarkdown);
                this.saveState(`Edit panel ${panelId}`);
                this.exitMarkdownEdit(contentElement);
            };
            
            // Handle cancel
            const handleCancel = () => {
                this.exitMarkdownEdit(contentElement);
                // Restore original content
                const originalMarkdown = this.markdownContent.get(panelId) || '';
                this.setPanelHtml(panelId, this.markdownConverter.makeHtml(originalMarkdown));
            };
            
            // Auto-save on blur (clicking away)
            const handleBlur = () => {
                setTimeout(() => {
                    // Only save if we're still in edit mode (not cancelled)
                    if (this.currentEdit && this.currentEdit.textarea === textarea) {
                        handleSave();
                    }
                }, 100); // Small delay to allow for button clicks
            };
            
            // Keyboard shortcuts
            const handleKeyDown = (e) => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 's') {
                        e.preventDefault();
                        handleSave();
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    handleCancel();
                }
            };
            
            textarea.addEventListener('keydown', handleKeyDown);
            textarea.addEventListener('blur', handleBlur);
            
            // Store cleanup function
            this.currentEdit = {
                textarea,
                handleKeyDown,
                handleBlur,
                handleSave,
                handleCancel,
                contentElement
            };
        }

        exitMarkdownEdit(contentElement) {
            if (!this.currentEdit) return;
            
            const { textarea, handleKeyDown, handleBlur } = this.currentEdit;
            
            // Remove event listeners
            textarea.removeEventListener('keydown', handleKeyDown);
            textarea.removeEventListener('blur', handleBlur);
            
            // Clean up
            this.currentEdit = null;
        }

        saveLayoutToFile() {
            // Create layout data including tree structure and markdown content
            const layoutData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                tree: this.root.toJSON(),
                markdown: Object.fromEntries(this.markdownContent),
                panelCount: this.nextPanelNumber
            };

            // Convert to JSON string with pretty formatting
            const jsonString = JSON.stringify(layoutData, null, 2);
            
            // Create blob and download link
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create temporary download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `panel-layout-${new Date().toISOString().slice(0, 10)}.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            URL.revokeObjectURL(url);
        }

        loadLayoutFromFile() {
            // Create file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const layoutData = JSON.parse(e.target.result);
                        this.loadLayout(layoutData);
                    } catch (error) {
                        alert('Failed to load layout: Invalid JSON file');
                        console.error('Layout load error:', error);
                    }
                };
                reader.readAsText(file);
            });
            
            // Trigger file picker
            fileInput.click();
        }

        loadLayout(layoutData) {
            // Validate layout data
            if (!layoutData.tree || !layoutData.version) {
                alert('Invalid layout file format');
                return;
            }

            // Clear current layout
            this.container.innerHTML = '';
            this.panels.clear();
            this.resizers = [];
            this.history.clear();
            
            // Restore panel count
            this.nextPanelNumber = layoutData.panelCount || 1;
            
            // Restore markdown content
            this.markdownContent = new Map(Object.entries(layoutData.markdown || {}));
            
            // Create all panel elements first
            const panelElementsMap = new Map();
            const createPanelElements = (node) => {
                if (node.leaf) {
                    // Extract panel number from ID (e.g., "panel-3-1751524681459" -> 3)
                    const panelNumberMatch = node.id.match(/^panel-(\d+)-/);
                    const panelNumber = panelNumberMatch ? parseInt(panelNumberMatch[1]) : 0;
                    
                    const customName = this.getCustomPanelName(panelNumber);
                    const element = this.createPanelElement(panelNumber, customName);
                    element.dataset.panelId = node.id;
                    
                    // Set special classes if needed
                    if (node.isMainContent) {
                        // No special class needed for main content in this implementation
                    }
                    
                    panelElementsMap.set(node.id, element);
                } else if (node.children) {
                    node.children.forEach(createPanelElements);
                }
            };
            createPanelElements(layoutData.tree);
            
            // Rebuild BSP tree with element references
            this.root = BSPNode.fromJSON(layoutData.tree, null, panelElementsMap);
            
            // Sync panels map
            const syncPanels = (node) => {
                if (node.isLeaf()) {
                    this.panels.set(node.id, { node, element: node.element });
                    if (!node.isToolbar) {
                        const markdown = this.markdownContent.get(node.id) || '';
                        this.setPanelMarkdown(node.id, markdown);
                    }
                } else {
                    node.children.forEach(syncPanels);
                }
            };
            syncPanels(this.root);
            
            // Identify and set up toolbar panels
            this.panels.forEach((panel, id) => {
                if (panel.node.isToolbar) {
                    if (panel.element.classList.contains('action-bar-panel') || 
                        (this.root.children && this.root.children[0] && this.root.children[0].id === id)) {
                        // This is the action bar panel
                        panel.element.classList.add('action-bar-panel');
                        const actionBarContent = `
                            <div class="action-bar-content">
                                <div class="action-list">
                                    <button class="action-item" data-action="new-document" title="New Document">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>
                                    </button>
                                    <button class="action-item" data-action="open-file" title="Open File">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                                    </button>
                                    <button class="action-item" data-action="save" title="Save">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                                    </button>
                                </div>
                            </div>
                        `;
                        this.setPanelHtml(id, actionBarContent);

                        // If collapsed, move action buttons to header
                        if (panel.node.isCollapsed) {
                            const actionList = panel.element.querySelector('.action-list');
                            const header = panel.element.querySelector('.panel-header');
                            if (actionList && header) {
                                header.appendChild(actionList);
                            }
                        }
                    } else {
                        // This is the header panel
                        panel.element.classList.add('header-panel');
                        
                        // Set up the file menu in the header
                        const headerElement = panel.element.querySelector('.panel-header');
                        if (headerElement) {
                            headerElement.innerHTML = `
                                <div class="file-menu">
                                    <span class="menu-item" data-menu="file">File</span>
                                    <span class="menu-item" data-menu="edit">Edit</span>
                                    <span class="menu-item" data-menu="view">View</span>
                                    <span class="menu-item" data-menu="terminal">Terminal</span>
                                    <span class="menu-item" data-menu="help">Help</span>
                                </div>
                                <div class="header-toolbar">
                                    <button class="btn" data-action="add-panel" title="Add Panel">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                                    </button>
                                    <button class="btn" data-action="reset-layout" title="Reset Layout">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                                    </button>
                                    <button class="btn" data-action="undo" id="header-undo-btn" title="Undo (Ctrl+Z)" disabled>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                                    </button>
                                    <button class="btn" data-action="redo" id="header-redo-btn" title="Redo (Ctrl+Y)" disabled>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 14 5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                                    </button>
                                    <div class="toolbar-separator"></div>
                                    <button class="btn" data-action="save-layout" title="Save Layout as JSON">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                                    </button>
                                    <button class="btn" data-action="load-layout" title="Load Layout from JSON">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M10 15l2 2 4-4"/></svg>
                                    </button>
                                </div>
                            `;
                        }
                        
                        const markdownToolbar = `
                            <div class="markdown-toolbar" style="display: none;">
                                <!-- Content moved to header -->
                            </div>
                        `;
                        this.setPanelHtml(id, markdownToolbar);

                        // Collapsed state is already handled since toolbar is in header
                    }
                }
            });
            
            // Restore markdown content for non-toolbar panels
            this.panels.forEach((panel, id) => {
                if (!panel.node.isToolbar) {
                    const markdown = this.markdownContent.get(id) || '';
                    if (markdown) {
                        this.setPanelMarkdown(id, markdown);
                    }
                }
            });
            
            // Final layout
            this.layout();
            this.saveState("Load Layout");
        }
    }

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', () => {
        const panelContainer = document.getElementById('panel-container');
        if (panelContainer) {
            window.panelManager = new PanelManager(panelContainer);
            window.panelManager.init();
        } else {
            console.error('Panel container not found.');
        }
    });

})();
