(function() {
    'use strict';

    // ===== DEFAULT LAYOUT DATA =====
    const DEFAULT_LAYOUT = {
        "version": "1.0",
        "timestamp": "2025-07-03T06:39:44.916Z",
        "tree": {
            "id": "5ad14758-daac-4b2c-8592-fece794bdb50",
            "direction": "vertical",
            "split": 0.011787819253438114,
            "isPinned": false,
            "isCollapsed": false,
            "isMainContent": false,
            "children": [
                {
                    "id": "panel-2-1751524681458",
                    "direction": null,
                    "split": 0.5,
                    "isPinned": true,
                    "isCollapsed": true,
                    "isMainContent": false,
                    "children": [],
                    "leaf": true
                },
                {
                    "id": "bd242593-1244-400d-be52-eb677bdc5a4d",
                    "direction": "vertical",
                    "split": 0.8791500988234562,
                    "isPinned": false,
                    "isCollapsed": false,
                    "isMainContent": false,
                    "children": [
                        {
                            "id": "7ee4d068-e236-477e-8ffe-39f1c7f01461",
                            "direction": "horizontal",
                            "split": 0.967802523190329,
                            "isPinned": false,
                            "isCollapsed": false,
                            "isMainContent": false,
                            "children": [
                                {
                                    "id": "d90ec94e-7e9f-4069-b1c3-ad3ab8afe391",
                                    "direction": "horizontal",
                                    "split": 0.07962138663646175,
                                    "isPinned": false,
                                    "isCollapsed": false,
                                    "isMainContent": false,
                                    "children": [
                                        {
                                            "id": "panel-1-1751524681458",
                                            "direction": null,
                                            "split": 0.5,
                                            "isPinned": true,
                                            "isCollapsed": true,
                                            "isMainContent": false,
                                            "children": [],
                                            "leaf": true
                                        },
                                        {
                                            "id": "cc44a063-87be-4a2f-b5e1-fda11ab4c7bd",
                                            "direction": "vertical",
                                            "split": 0.5,
                                            "isPinned": false,
                                            "isCollapsed": false,
                                            "isMainContent": false,
                                            "children": [
                                                {
                                                    "id": "fc3915bc-6529-475d-9c4b-278e97199a3a",
                                                    "direction": "vertical",
                                                    "split": 0.2956653882609988,
                                                    "isPinned": false,
                                                    "isCollapsed": false,
                                                    "isMainContent": false,
                                                    "children": [
                                                        {
                                                            "id": "panel-3-1751524681459",
                                                            "direction": null,
                                                            "split": 0.5,
                                                            "isPinned": true,
                                                            "isCollapsed": false,
                                                            "isMainContent": false,
                                                            "children": [],
                                                            "leaf": true
                                                        },
                                                        {
                                                            "id": "df615640-943f-49d6-adf9-f3acc7f8dcd4",
                                                            "direction": "vertical",
                                                            "split": 0.5,
                                                            "isPinned": false,
                                                            "isCollapsed": false,
                                                            "isMainContent": false,
                                                            "children": [
                                                                {
                                                                    "id": "panel-10-1751524681464",
                                                                    "direction": null,
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "children": [],
                                                                    "leaf": true
                                                                },
                                                                {
                                                                    "id": "panel-7-1751524681463",
                                                                    "direction": null,
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "children": [],
                                                                    "leaf": true
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                },
                                                {
                                                    "id": "b49e17af-e8fd-4d2b-9b51-419e2bc72de2",
                                                    "direction": "horizontal",
                                                    "split": 0.5,
                                                    "isPinned": false,
                                                    "isCollapsed": false,
                                                    "isMainContent": false,
                                                    "children": [
                                                        {
                                                            "id": "panel-4-1751524681459",
                                                            "direction": null,
                                                            "split": 0.5,
                                                            "isPinned": false,
                                                            "isCollapsed": false,
                                                            "isMainContent": true,
                                                            "children": [],
                                                            "leaf": true
                                                        },
                                                        {
                                                            "id": "d2f995a6-d967-473e-b2b5-8c255fb7610a",
                                                            "direction": "vertical",
                                                            "split": 0.5,
                                                            "isPinned": false,
                                                            "isCollapsed": false,
                                                            "isMainContent": false,
                                                            "children": [
                                                                {
                                                                    "id": "panel-9-1751524681463",
                                                                    "direction": null,
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "children": [],
                                                                    "leaf": true
                                                                },
                                                                {
                                                                    "id": "1955b473-21f1-45a1-a669-f56193aa419c",
                                                                    "direction": "horizontal",
                                                                    "split": 0.5,
                                                                    "isPinned": false,
                                                                    "isCollapsed": false,
                                                                    "isMainContent": false,
                                                                    "children": [
                                                                        {
                                                                            "id": "panel-8-1751524681463",
                                                                            "direction": null,
                                                                            "split": 0.5,
                                                                            "isPinned": false,
                                                                            "isCollapsed": false,
                                                                            "isMainContent": false,
                                                                            "children": [],
                                                                            "leaf": true
                                                                        },
                                                                        {
                                                                            "id": "panel-11-1751524681464",
                                                                            "direction": null,
                                                                            "split": 0.5,
                                                                            "isPinned": false,
                                                                            "isCollapsed": false,
                                                                            "isMainContent": false,
                                                                            "children": [],
                                                                            "leaf": true
                                                                        }
                                                                    ]
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "id": "panel-5-1751524681459",
                                    "direction": null,
                                    "split": 0.5,
                                    "isPinned": true,
                                    "isCollapsed": false,
                                    "isMainContent": false,
                                    "children": [],
                                    "leaf": true
                                }
                            ]
                        },
                        {
                            "id": "panel-6-1751524681459",
                            "direction": null,
                            "split": 0.5,
                            "isPinned": true,
                            "isCollapsed": false,
                            "isMainContent": false,
                            "children": [],
                            "leaf": true
                        }
                    ]
                }
            ]
        },
        "markdown": {
            "panel-3-1751524681459": "### Panel 3\n\nContent Area.",
            "panel-4-1751524681459": "# Responsive\n\nDraggable content area.",
            "panel-5-1751524681459": "### Panel 5\n\nContent Area.",
            "panel-6-1751524681459": "### Panel 6\n\nContent Area.",
            "panel-7-1751524681463": "# Efficient\n\nDraggable content area.",
            "panel-8-1751524681463": "# Efficient\n\nDraggable content area.",
            "panel-9-1751524681463": "# Modular\n\nDraggable content area.",
            "panel-10-1751524681464": "# Organized\n\nDraggable content area.",
            "panel-11-1751524681464": "# Fluid\n\nDraggable content area."
        },
        "panelCount": 12
    };

    // ===== CONFIGURATION =====
    const CONFIG = {
        RESIZER_THICKNESS: 5,
        PANEL_MIN_HEIGHT: 40,
        PANEL_MIN_WIDTH: 150,
        COLLAPSED_SIZE: 30, // Corresponds to header height/width
        DRAG_COLLAPSE_THRESHOLD: 20,
        DEFAULT_SPLIT: 0.5,
        HISTORY_LIMIT: 50,
        ANIMATION_DURATION: 150,
        EASING: 'cubic-bezier(0.4, 0, 0.2, 1)',
        PANEL_ANIMATION_CLASS: 'panel-grow-in',
    };

    // ===== UTILITY CLASSES =====

    /**
     * A simple event emitter for pub/sub communication.
     */
    class EventEmitter {
        constructor() {
            this.events = new Map();
        }
        on(event, listener) {
            if (!this.events.has(event)) {
                this.events.set(event, []);
            }
            this.events.get(event).push(listener);
        }
        emit(event, payload) {
            if (this.events.has(event)) {
                this.events.get(event).forEach(listener => listener(payload));
            }
        }
    }

    /**
     * Manages the state history for undo/redo functionality.
     */
    class HistoryManager {
        constructor(limit) {
            this.limit = limit;
            this.history = [];
            this.pointer = -1;
            this.emitter = new EventEmitter();
        }
        
        add(state) {
            if (this.pointer < this.history.length - 1) {
                this.history.splice(this.pointer + 1);
            }
            this.history.push(state);
            if (this.history.length > this.limit) {
                this.history.shift();
            }
            this.pointer = this.history.length - 1;
            this.emitChange();
        }

        undo() {
            if (this.canUndo()) {
                this.pointer--;
                this.emitChange();
                return this.history[this.pointer];
            }
            return null;
        }

        redo() {
            if (this.canRedo()) {
                this.pointer++;
                this.emitChange();
                return this.history[this.pointer];
            }
            return null;
        }

        canUndo() { return this.pointer > 0; }
        canRedo() { return this.pointer < this.history.length - 1; }
        
        on(event, listener) { this.emitter.on(event, listener); }
        emitChange() { this.emitter.emit('change', { canUndo: this.canUndo(), canRedo: this.canRedo() }); }
        
        clear() {
            this.history = [];
            this.pointer = -1;
            this.emitChange();
        }
    }

    /**
     * Represents a node in the Binary Space Partitioning (BSP) tree.
     */
    class BSPNode {
        constructor(options = {}) {
            this.id = options.id || self.crypto.randomUUID();
            this.parent = options.parent || null;
            this.children = options.children || [];
            this.direction = options.direction || null;
            this.split = options.split || CONFIG.DEFAULT_SPLIT;
            this.element = options.element || null; 
            this.isPinned = options.isPinned || false;
            this.isCollapsed = options.isCollapsed || false;
            this.isMainContent = options.isMainContent || false;
        }

        isLeaf() { return this.children.length === 0; }

        getSibling() {
            if (!this.parent) return null;
            return this.parent.children.find(child => child !== this);
        }

        clone(parent = null) {
            const newChildren = [];
            const newInstance = new BSPNode({
                id: this.id,
                parent,
                direction: this.direction,
                split: this.split,
                isPinned: this.isPinned,
                isCollapsed: this.isCollapsed,
                isMainContent: this.isMainContent,
                children: newChildren,
                element: this.element // Keep reference to original element
            });
            newChildren.push(...this.children.map(c => c.clone(newInstance)));
            return newInstance;
        }

        toJSON() {
            const obj = {
                id: this.id,
                direction: this.direction,
                split: this.split,
                isPinned: this.isPinned,
                isCollapsed: this.isCollapsed,
                isMainContent: this.isMainContent,
                children: this.children.map(c => c.toJSON())
            };
            if (this.isLeaf()) obj.leaf = true;
            return obj;
        }

        static fromJSON(json, parent, panelElementsMap) {
            const node = new BSPNode({ ...json, parent });
            if (json.leaf) {
                node.element = panelElementsMap.get(json.id);
            } else {
                node.children = json.children.map(childJson => 
                    BSPNode.fromJSON(childJson, node, panelElementsMap)
                );
            }
            return node;
        }
    }

    /**
     * Manages the entire panel grid system.
     */
    class PanelManager {
        constructor(container) {
            this.container = container;
            this.panels = new Map();
            this.resizers = [];
            this.root = null;
            this.previewRoot = null;
            this.isPreviewMode = false;
            this.lastDragOverTarget = { panelId: null, zone: null };
            this.nextPanelNumber = 1;
            this.history = new HistoryManager(CONFIG.HISTORY_LIMIT);
            this.minSizeCache = new Map();
            this.markdownConverter = new showdown.Converter();
            this.markdownContent = new Map();
            this.alignmentGuides = [];

            this.handlePointerDown = this.handlePointerDown.bind(this);
            this.handlePointerMove = this.handlePointerMove.bind(this);
            this.handlePointerUp = this.handlePointerUp.bind(this);
            this.handleDragOver = this.handleDragOver.bind(this);
            this.updatePreviewLayout = this.updatePreviewLayout.bind(this);
        }

        init() {
            this.setupUI();
            // Load default layout instead of resetLayout
            this.loadLayout(DEFAULT_LAYOUT);
            this.setupEventListeners();
        }

        setupUI() {
            this.dom = {
                addPanelBtn: null,
                resetLayoutBtn: null,
                undoBtn: null,
                redoBtn: null,
            };
        }
        
        setupEventListeners() {
            this.container.addEventListener('pointerdown', this.handlePointerDown);
            window.addEventListener('resize', () => this.layout());
            
            // Add double-click event listener for markdown editing
            this.container.addEventListener('dblclick', this.handleDoubleClick.bind(this));
            
            if (this.dom.addPanelBtn) this.dom.addPanelBtn.addEventListener('click', () => this.addPanel());
            if (this.dom.resetLayoutBtn) this.dom.resetLayoutBtn.addEventListener('click', () => this.resetLayout());
            if (this.dom.undoBtn) this.dom.undoBtn.addEventListener('click', () => this.undo());
            if (this.dom.redoBtn) this.dom.redoBtn.addEventListener('click', () => this.redo());
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
                        e.preventDefault();
                        this.redo();
                    }
                }
            });
        }

        resetLayout() {
            // 1. Cleanup
            this.container.innerHTML = '';
            this.panels.clear();
            this.resizers = [];
            this.nextPanelNumber = 1;
            this.history.clear();

            // 2. Create the six panels (added action bar)
            const headerPanel = this.createPanel();
            headerPanel.element.classList.add('header-panel');
            const actionBarPanel = this.createPanel();
            actionBarPanel.element.classList.add('action-bar-panel');
            const leftPanel = this.createPanel();
            const mainPanel = this.createPanel();
            const rightPanel = this.createPanel();
            const footerPanel = this.createPanel();

            // 3. Create the BSP nodes for each panel
            const headerNode = new BSPNode({ id: headerPanel.id, element: headerPanel.element, isPinned: true });
            const actionBarNode = new BSPNode({ id: actionBarPanel.id, element: actionBarPanel.element, isPinned: true });
            const leftNode = new BSPNode({ id: leftPanel.id, element: leftPanel.element, isPinned: true });
            const mainNode = new BSPNode({ id: mainPanel.id, element: mainPanel.element, isMainContent: true });
            const rightNode = new BSPNode({ id: rightPanel.id, element: rightPanel.element, isPinned: true });
            const footerNode = new BSPNode({ id: footerPanel.id, element: footerPanel.element, isPinned: true });

            // 4. Build the tree structure from the bottom up for the content area
            const rightContainer = new BSPNode({
                direction: 'horizontal', // mainNode is on the left of rightNode
                split: 0.8, children: [mainNode, rightNode]
            });
            mainNode.parent = rightContainer;
            rightNode.parent = rightContainer;

            // This container will hold the header panel (now on the left) and the left panel, side-by-side
            const headerAndLeftContainer = new BSPNode({
                direction: 'horizontal',
                split: 0.25,
                children: [headerNode, leftNode]
            });
            headerNode.parent = headerAndLeftContainer;
            leftNode.parent = headerAndLeftContainer;

            const topContentContainer = new BSPNode({
                direction: 'horizontal',
                split: 0.2,
                children: [headerAndLeftContainer, rightContainer]
            });
            headerAndLeftContainer.parent = topContentContainer;
            rightContainer.parent = topContentContainer;
            
            const mainBodyContainer = new BSPNode({
                direction: 'vertical', // The main content area is above the footer
                split: 0.9, children: [topContentContainer, footerNode]
            });
            topContentContainer.parent = mainBodyContainer;
            footerNode.parent = mainBodyContainer;

            // 5. Create the root, with the action bar (now on top) above the main body
            this.root = new BSPNode({
                direction: 'vertical',
                split: 0.08, // The action bar gets 8% of the total height
                children: [actionBarNode, mainBodyContainer]
            });
            actionBarNode.parent = this.root;
            mainBodyContainer.parent = this.root;

            // 6. Populate the global panels map with the structural panels
            this.panels.set(headerPanel.id, { node: headerNode, element: headerPanel.element });
            this.panels.set(actionBarPanel.id, { node: actionBarNode, element: actionBarPanel.element });
            this.panels.set(leftPanel.id, { node: leftNode, element: leftPanel.element });
            this.panels.set(mainPanel.id, { node: mainNode, element: mainPanel.element });
            this.panels.set(rightPanel.id, { node: rightNode, element: rightPanel.element });
            this.panels.set(footerPanel.id, { node: footerNode, element: footerPanel.element });
            
            // 7. Run layout to get dimensions, then generate the fractal pattern
            this.layout();
            this.createRandomPattern(mainNode, 5); // Generate 5 random splits

            // 8. Set content for all panels based on their state
            const randomWords = ["Dynamic", "Fluid", "Modular", "Intuitive", "Responsive", "Creative", "Organized", "Productive", "Efficient", "Seamless", "Integrated"];

            this.panels.forEach((panel, id) => {
                if (panel.element.classList.contains('header-panel') || panel.element.classList.contains('action-bar-panel')) {
                    return; // Skip header and action bar panels
                }

                if (panel.node.isPinned) {
                    const defaultMarkdown = `### ${panel.element.querySelector('.panel-title').textContent}\n\nContent Area.`;
                    this.setPanelMarkdown(id, defaultMarkdown);
                } else {
                    const randomWord = randomWords[Math.floor(Math.random() * randomWords.length)];
                    const specialMarkdown = `# ${randomWord}\n\nDraggable content area.`;
                    this.setPanelMarkdown(id, specialMarkdown);
                }
            });
            
            const markdownToolbar = `
                <div class="markdown-toolbar">
                    <button class="btn" data-action="add-panel" title="Add Panel">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                    </button>
                    <button class="btn" data-action="reset-layout" title="Reset Layout">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                    </button>
                    <button class="btn" data-action="undo" id="header-undo-btn" title="Undo (Ctrl+Z)" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                    </button>
                    <button class="btn" data-action="redo" id="header-redo-btn" title="Redo (Ctrl+Y)" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 14 5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                    </button>
                    <div class="toolbar-separator"></div>
                    <button class="btn" data-action="save-layout" title="Save Layout as JSON">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                    </button>
                    <button class="btn" data-action="load-layout" title="Load Layout from JSON">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M10 15l2 2 4-4"/></svg>
                    </button>
                </div>
            `;
            this.setPanelHtml(headerNode.id, markdownToolbar);

            const actionBarContent = `
                <div class="action-bar-content">
                    <div class="action-list">
                        <button class="action-item" data-action="new-document" title="New Document">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>
                        </button>
                        <button class="action-item" data-action="open-file" title="Open File">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                        </button>
                        <button class="action-item" data-action="save" title="Save">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                        </button>
                    </div>
                </div>
            `;
            this.setPanelHtml(actionBarNode.id, actionBarContent);

            // 10. Final layout pass and save
            this.layout();
            this.saveState("Initial Pinned Layout");
        }

        saveState(action) {
            const serializedTree = this.root.toJSON();
            const markdownData = Object.fromEntries(this.markdownContent);
            this.history.add({ action, tree: serializedTree, markdown: markdownData });
        }
        
        restoreState(state) {
            // TODO: This does not handle undoing panel creation/deletion correctly,
            // as the panel DOM elements may not exist in the current state.
            // It works for state changes on existing panels, like content edits.
            const panelElementsMap = new Map();
            this.panels.forEach(p => panelElementsMap.set(p.node.id, p.element));
            
            this.markdownContent = new Map(Object.entries(state.markdown || {}));
            this.root = BSPNode.fromJSON(state.tree, null, panelElementsMap);
            
            this.panels.clear();
            const syncPanels = (node) => {
                if (node.isLeaf()) {
                    this.panels.set(node.id, { node, element: node.element });
                    if (!node.element.classList.contains('header-panel')) {
                        const markdown = this.markdownContent.get(node.id) || '';
                        this.setPanelMarkdown(node.id, markdown);
                    }
                } else {
                    node.children.forEach(syncPanels);
                }
            };
            syncPanels(this.root);
            
            this.layout();
            
            const headerPanel = Array.from(this.panels.values()).find(p => p.element.classList.contains('header-panel'));
            if (headerPanel) {
                const markdownToolbar = `
                    <div class="markdown-toolbar">
                        <button class="btn" data-action="add-panel" title="Add Panel">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                        </button>
                        <button class="btn" data-action="reset-layout" title="Reset Layout">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                        </button>
                        <button class="btn" data-action="undo" id="header-undo-btn" title="Undo (Ctrl+Z)" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                        </button>
                        <button class="btn" data-action="redo" id="header-redo-btn" title="Redo (Ctrl+Y)" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 14 5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                        </button>
                        <div class="toolbar-separator"></div>
                        <button class="btn" data-action="save-layout" title="Save Layout as JSON">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                        </button>
                        <button class="btn" data-action="load-layout" title="Load Layout from JSON">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M10 15l2 2 4-4"/></svg>
                        </button>
                    </div>
                `;
                this.setPanelHtml(headerPanel.node.id, markdownToolbar);
            }

            const actionBarPanel = Array.from(this.panels.values()).find(p => p.element.classList.contains('action-bar-panel'));
            if (actionBarPanel) {
                const actionBarContent = `
                    <div class="action-bar-content">
                        <div class="action-list">
                            <button class="action-item" data-action="new-document" title="New Document">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>
                            </button>
                            <button class="action-item" data-action="open-file" title="Open File">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                            </button>
                            <button class="action-item" data-action="save" title="Save">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                            </button>
                        </div>
                    </div>
                `;
                this.setPanelHtml(actionBarPanel.node.id, actionBarContent);
            }
        }
        
        undo() {
            const state = this.history.undo();
            if (state) this.restoreState(state);
        }

        redo() {
            const state = this.history.redo();
            if (state) this.restoreState(state);
        }

        layout(isPreview = false) {
            const tree = isPreview ? this.previewRoot : this.root;
            if (!tree) return;

            const computedStyle = getComputedStyle(this.container);
            const paddingLeft = parseFloat(computedStyle.paddingLeft);
            const paddingTop = parseFloat(computedStyle.paddingTop);
            const paddingRight = parseFloat(computedStyle.paddingRight);
            const paddingBottom = parseFloat(computedStyle.paddingBottom);

            this.minSizeCache.clear();
            
            if (!isPreview) {
                this.resizers.forEach(r => r.remove());
                this.resizers = [];
            }

            const layoutRecursive = (node, rect) => {
                node.rect = rect;

                if (node.isLeaf()) {
                    Object.assign(node.element.style, {
                        left: `${rect.x}px`, top: `${rect.y}px`,
                        width: `${rect.width}px`, height: `${rect.height}px`
                    });
                    if (!isPreview) {
                       this.updatePanelControls(node);
                    }
                    return;
                }

                const [child1, child2] = node.children;
                let rect1, rect2;

                if (node.direction === 'vertical') {
                    const availableWidth = rect.width - CONFIG.RESIZER_THICKNESS;
                    let width1, width2;
                    const child1Collapsed = child1.isLeaf() && child1.isCollapsed;
                    const child2Collapsed = child2.isLeaf() && child2.isCollapsed;

                    if (child1Collapsed) {
                        width1 = CONFIG.COLLAPSED_SIZE;
                        width2 = availableWidth - width1;
                    } else if (child2Collapsed) {
                        width2 = CONFIG.COLLAPSED_SIZE;
                        width1 = availableWidth - width2;
                    } else {
                        const minWidth1 = this.calculateMinimumWidth(child1);
                        const minWidth2 = this.calculateMinimumWidth(child2);
                        const totalMinWidth = minWidth1 + minWidth2;
                        if (totalMinWidth > availableWidth) {
                            node.split = (totalMinWidth > 0) ? (minWidth1 / totalMinWidth) : 0.5;
                        }

                        width1 = Math.max(minWidth1, availableWidth * node.split);
                        width2 = availableWidth - width1;
                        if (width2 < minWidth2) {
                            width2 = minWidth2;
                            width1 = availableWidth - width2;
                        }
                    }
                    if (availableWidth > 0) node.split = width1 / availableWidth;
                    
                    rect1 = { ...rect, width: width1 };
                    rect2 = { ...rect, x: rect.x + width1 + CONFIG.RESIZER_THICKNESS, width: width2 };

                    if (!isPreview) {
                        const resizerX = rect.x + width1;
                        const resizer = this.createResizer(node, resizerX, rect.y, CONFIG.RESIZER_THICKNESS, rect.height, 'vertical');
                        this.resizers.push(resizer);
                    }
                } else {
                    const availableHeight = rect.height - CONFIG.RESIZER_THICKNESS;
                    let height1, height2;
                    const child1Collapsed = child1.isLeaf() && child1.isCollapsed;
                    const child2Collapsed = child2.isLeaf() && child2.isCollapsed;

                    if (child1Collapsed) {
                        height1 = CONFIG.COLLAPSED_SIZE;
                        height2 = availableHeight - height1;
                    } else if (child2Collapsed) {
                        height2 = CONFIG.COLLAPSED_SIZE;
                        height1 = availableHeight - height2;
                    } else {
                        const minHeight1 = this.calculateMinimumHeight(child1);
                        const minHeight2 = this.calculateMinimumHeight(child2);
                        const totalMinHeight = minHeight1 + minHeight2;
                        if (totalMinHeight > availableHeight) {
                            node.split = (totalMinHeight > 0) ? (minHeight1 / totalMinHeight) : 0.5;
                        }

                        height1 = Math.max(minHeight1, availableHeight * node.split);
                        height2 = availableHeight - height1;
                        if (height2 < minHeight2) {
                            height2 = minHeight2;
                            height1 = availableHeight - height2;
                        }
                    }
                    if (availableHeight > 0) node.split = height1 / availableHeight;
                    
                    rect1 = { ...rect, height: height1 };
                    rect2 = { ...rect, y: rect.y + height1 + CONFIG.RESIZER_THICKNESS, height: height2 };
                    
                    if (!isPreview) {
                        const resizerY = rect.y + height1;
                        const resizer = this.createResizer(node, rect.x, resizerY, rect.width, CONFIG.RESIZER_THICKNESS, 'horizontal');
                        this.resizers.push(resizer);
                    }
                }

                layoutRecursive(child1, rect1);
                layoutRecursive(child2, rect2);
            };
            
            const containerRect = this.container.getBoundingClientRect();
            const layoutWidth = containerRect.width - paddingLeft - paddingRight;
            const layoutHeight = containerRect.height - paddingTop - paddingBottom;
            
            layoutRecursive(tree, { x: paddingLeft, y: paddingTop, width: layoutWidth, height: layoutHeight });
        }

        createPanelElement(panelNumber) {
            const element = document.createElement('div');
            element.className = `panel ${CONFIG.PANEL_ANIMATION_CLASS}`;
            element.innerHTML = `
                <div class="panel-header">
                    <button class="panel-action-btn" data-action="pin" title="Pin Panel">
                        <svg class="icon-pin" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="8"/></svg>
                        <svg class="icon-pin-off" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="8"/></svg>
                    </button>
                    <span class="panel-title">Panel ${panelNumber}</span>
                    <div class="panel-actions">
                        <button class="panel-action-btn" data-action="collapse" title="Collapse Panel"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
                        <button class="panel-action-btn" data-action="split-v" title="Split Vertically"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><line x1="12" y1="3" x2="12" y2="21"/></svg></button>
                        <button class="panel-action-btn" data-action="split-h" title="Split Horizontally"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><line x1="3" y1="12" x2="21" y2="12"/></svg></button>
                        <button class="panel-action-btn" data-action="close" title="Close Panel"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg></button>
                    </div>
                </div>
                <div class="panel-content"></div>`;
            
            element.addEventListener('animationend', () => element.classList.remove(CONFIG.PANEL_ANIMATION_CLASS), { once: true });
            this.container.appendChild(element);
            return element;
        }

        createPanel() {
            const panelNumber = this.nextPanelNumber++;
            const element = this.createPanelElement(panelNumber);
            const id = `panel-${panelNumber}-${Date.now()}`;
            element.dataset.panelId = id;
            return { id, element };
        }
        
        addPanel() {
            let largestUnpinnedLeaf = null;
            let maxArea = -1;

            const findLargestLeaf = (node) => {
                if (node.isLeaf() && !node.isPinned) {
                    const area = node.rect.width * node.rect.height;
                    if (area > maxArea) {
                        maxArea = area;
                        largestUnpinnedLeaf = node;
                    }
                } else if (!node.isLeaf()) {
                    node.children.forEach(findLargestLeaf);
                }
            };

            findLargestLeaf(this.root);

            if (largestUnpinnedLeaf) {
                const targetNode = largestUnpinnedLeaf;
                const canSplitV = targetNode.rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
                const canSplitH = targetNode.rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;

                const isWider = targetNode.rect.width > targetNode.rect.height;

                if (isWider) {
                    // Prefer vertical split for wider panels
                    if (canSplitV) {
                        this.splitPanel(targetNode.id, 'vertical');
                    } else if (canSplitH) {
                        this.splitPanel(targetNode.id, 'horizontal');
                    }
                } else {
                    // Prefer horizontal split for taller or square panels
                    if (canSplitH) {
                        this.splitPanel(targetNode.id, 'horizontal');
                    } else if (canSplitV) {
                        this.splitPanel(targetNode.id, 'vertical');
                    }
                }
            }
        }
        
        splitPanel(targetId, direction, suppressLayout = false) {
            const target = this.panels.get(targetId);
            if (!target) return null;
            const { node: targetNode } = target;

            if (targetNode.rect) { // Only check if rect is available
                if (direction === 'vertical') {
                    const canSplitV = targetNode.rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
                    if (!canSplitV) return null;
                } else { // horizontal
                    const canSplitH = targetNode.rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;
                    if (!canSplitH) return null;
                }
            }

            const newPanel = this.createPanel();
            const newNode = new BSPNode({ id: newPanel.id, element: newPanel.element });
            this.panels.set(newPanel.id, { node: newNode, element: newPanel.element });
            
            const newParent = new BSPNode({
                parent: targetNode.parent,
                direction,
                children: [targetNode, newNode],
                split: 0.3 + Math.random() * 0.4
            });

            targetNode.parent = newParent;
            newNode.parent = newParent;

            if (this.root === targetNode) {
                this.root = newParent;
            } else {
                const oldParent = newParent.parent;
                if (!oldParent) return null; // Should not happen in a valid tree
                const targetIndex = oldParent.children.indexOf(targetNode);
                oldParent.children.splice(targetIndex, 1, newParent);
            }
            
            if (!suppressLayout) {
                this.layout();
                this.saveState(`Split ${direction}`);
            }
            return { oldNode: targetNode, newNode: newNode };
        }
        
        createRandomPattern(startNode, numSplits) {
            let leaves = [startNode];

            for (let i = 0; i < numSplits && leaves.length > 0; i++) {
                const leafIndex = Math.floor(Math.random() * leaves.length);
                const leafToSplit = leaves[leafIndex];
                leaves.splice(leafIndex, 1);

                const canSplitV = leafToSplit.rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
                const canSplitH = leafToSplit.rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;

                const possibleDirections = [];
                if (canSplitV) possibleDirections.push('vertical');
                if (canSplitH) possibleDirections.push('horizontal');

                if (possibleDirections.length === 0) continue;

                const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                
                const result = this.splitPanel(leafToSplit.id, direction, true);
                if (result) {
                    const { oldNode, newNode } = result;
                    
                    const parentRect = leafToSplit.rect;
                    const newParentNode = oldNode.parent;
                    let rect1, rect2;

                    if (direction === 'vertical') {
                        const availableWidth = parentRect.width - CONFIG.RESIZER_THICKNESS;
                        const width1 = availableWidth * newParentNode.split;
                        const width2 = availableWidth - width1;
                        rect1 = { ...parentRect, width: width1 };
                        rect2 = { ...parentRect, x: parentRect.x + width1 + CONFIG.RESIZER_THICKNESS, width: width2 };
                    } else {
                        const availableHeight = parentRect.height - CONFIG.RESIZER_THICKNESS;
                        const height1 = availableHeight * newParentNode.split;
                        const height2 = availableHeight - height1;
                        rect1 = { ...parentRect, height: height1 };
                        rect2 = { ...parentRect, y: parentRect.y + height1 + CONFIG.RESIZER_THICKNESS, height: height2 };
                    }
                    oldNode.rect = rect1;
                    newNode.rect = rect2;

                    leaves.push(oldNode, newNode);
                }
            }
        }

        closePanel(targetId) {
            const target = this.panels.get(targetId);
            if (!target || this.panels.size <= 1) return;
            const { node: targetNode } = target;

            const parent = targetNode.parent;
            const sibling = targetNode.getSibling();
            const grandparent = parent.parent;

            if (grandparent) {
                const parentIndex = grandparent.children.indexOf(parent);
                grandparent.children.splice(parentIndex, 1, sibling);
                sibling.parent = grandparent;
            } else {
                this.root = sibling;
                sibling.parent = null;
            }

            targetNode.element.remove();
            this.panels.delete(targetId);
            this.layout();
            this.saveState("Close Panel");
        }

        calculateMinimumHeight(node) {
            if (this.minSizeCache.has(node.id + '-h')) return this.minSizeCache.get(node.id + '-h');
            if (node.isLeaf()) return CONFIG.PANEL_MIN_HEIGHT;
            
            const [child1, child2] = node.children;
            const h1 = this.calculateMinimumHeight(child1);
            const h2 = this.calculateMinimumHeight(child2);
            
            const result = node.direction === 'horizontal' 
                ? h1 + h2 + CONFIG.RESIZER_THICKNESS 
                : Math.max(h1, h2);
            
            this.minSizeCache.set(node.id + '-h', result);
            return result;
        }

        calculateMinimumWidth(node) {
            if (this.minSizeCache.has(node.id + '-w')) return this.minSizeCache.get(node.id + '-w');
            if (node.isLeaf()) return CONFIG.PANEL_MIN_WIDTH;
            
            const [child1, child2] = node.children;
            const w1 = this.calculateMinimumWidth(child1);
            const w2 = this.calculateMinimumWidth(child2);
            
            const result = node.direction === 'vertical' 
                ? w1 + w2 + CONFIG.RESIZER_THICKNESS 
                : Math.max(w1, w2);

            this.minSizeCache.set(node.id + '-w', result);
            return result;
        }
        
        handlePointerDown(e) {
            const resizer = e.target.closest('.panel-resizer');
            const header = e.target.closest('.panel-header');
            const actionBtn = e.target.closest('.panel-action-btn');

            if (actionBtn) {
                this.handleActionClick(actionBtn);
                return;
            }
            
            if (resizer && !resizer.classList.contains('is-disabled')) {
                const nodeId = resizer.dataset.nodeId;
                const targetNode = this._findNodeById(this.root, nodeId);
                if (!targetNode) return;
                this.activeDrag = { type: 'resize', resizer, target: targetNode };
            } else if (header) {
                const targetNode = this.findNodeByElement(header.parentElement);
                if (targetNode && !targetNode.isPinned) {
                    this.activeDrag = { type: 'move', header, target: targetNode };
                }
            } else if (e.target.closest('.panel-content')) {
                const contentActionBtn = e.target.closest('button.btn');
                if (contentActionBtn) {
                    this.handleContentButtonClick(contentActionBtn);
                }
                return; // Clicks on content should not proceed
            }
            
            if (!this.activeDrag) return;

            e.preventDefault();
            this.activeDrag.startX = e.clientX;
            this.activeDrag.startY = e.clientY;
            
            this.container.classList.add('no-transition');
            document.body.style.cursor = this.activeDrag.type === 'resize' ? getComputedStyle(resizer).cursor : 'grabbing';

            window.addEventListener('pointermove', this.handlePointerMove);
            window.addEventListener('pointerup', this.handlePointerUp, { once: true });
        }
        
        handlePointerMove(e) {
            if (!this.activeDrag) return;

            if (this.activeDrag.type === 'resize') {
                this.handleResize(e);
            } else if (this.activeDrag.type === 'move' && !this.activeDrag.isDragging) {
                const dx = e.clientX - this.activeDrag.startX;
                const dy = e.clientY - this.activeDrag.startY;
                if (Math.hypot(dx, dy) > 5) {
                    this.initDrag();
                }
            }
        }
        
        handlePointerUp() {
            if (this.activeDrag?.isDragging) {
                this.handleDrop();
            } else if (this.activeDrag?.type === 'resize') {
                this.saveState("Resize");
            }
            
            const wasDragging = this.activeDrag?.isDragging;

            this.exitPreviewMode();

            this.container.classList.remove('no-transition');
            document.body.style.cursor = '';
            this.activeDrag = null;
            window.removeEventListener('pointermove', this.handlePointerMove);

            if (wasDragging) {
                this.layout();
            }
        }

        handleActionClick(button) {
            const action = button.dataset.action;
            const panelId = button.closest('.panel')?.dataset.panelId;
            if (!panelId) return;

            switch(action) {
                case 'pin': this.togglePin(panelId); break;
                case 'collapse': this.toggleCollapse(panelId); break;
                case 'split-v': this.splitPanel(panelId, 'vertical'); break;
                case 'split-h': this.splitPanel(panelId, 'horizontal'); break;
                case 'close': this.closePanel(panelId); break;
            }
        }
        
        handleContentButtonClick(button) {
            const action = button.dataset.action;
            const panelId = button.closest('.panel')?.dataset.panelId;

            const findMainPanel = () => {
                for (const panel of this.panels.values()) {
                    if (panel.node.isMainContent) return panel;
                }
                return null;
            };
            
            switch (action) {
                // Global App Actions
                case 'add-panel': this.addPanel(); break;
                case 'reset-layout': this.resetLayout(); break;
                case 'undo': this.undo(); break;
                case 'redo': this.redo(); break;
                case 'save-layout': this.saveLayoutToFile(); break;
                case 'load-layout': this.loadLayoutFromFile(); break;

                // Markdown Content Actions
                case 'add-h1':
                case 'add-bold':
                case 'add-italic':
                    const mainPanel = findMainPanel();
                    if (!mainPanel) {
                        alert("No main content panel found!");
                        return;
                    }
                    const currentMarkdown = this.markdownContent.get(mainPanel.node.id) || '';
                    let newMarkdown = currentMarkdown;
                    
                    if (action === 'add-h1') newMarkdown += '\n\n# New Header';
                    else if (action === 'add-bold') newMarkdown += '\n\n**Bold Text**';
                    else if (action === 'add-italic') newMarkdown += '\n\n*Italic Text*';

                    if (newMarkdown !== currentMarkdown) {
                        this.setPanelMarkdown(mainPanel.node.id, newMarkdown);
                        this.saveState("Edit Content");
                    }
                    break;

                // Test Action
                case 'test-alert':
                    alert(`Button clicked in panel: ${panelId}`);
                    break;
            }
        }
        
        handleResize(e) {
            const { target: node } = this.activeDrag;
            if (!node || node.isLeaf()) return;
            
            const parentRect = node.rect;
            if (node.direction === 'vertical') {
                const newSplit = (e.clientX - parentRect.x) / (parentRect.width - CONFIG.RESIZER_THICKNESS);
                const [child1, child2] = node.children;
                const availableWidth = parentRect.width - CONFIG.RESIZER_THICKNESS;
                const width1 = newSplit * availableWidth;
                const width2 = availableWidth - width1;
                
                // Drag-to-collapse logic
                if (child1.isLeaf() && child1.isPinned) {
                    if (!child1.isCollapsed && width1 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                    else if (child1.isCollapsed && width1 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                }
                if (child2.isLeaf() && child2.isPinned) {
                    if (!child2.isCollapsed && width2 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                    else if (child2.isCollapsed && width2 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                }
                
                node.split = newSplit;

            } else { // Horizontal resize
                const newSplit = (e.clientY - parentRect.y) / (parentRect.height - CONFIG.RESIZER_THICKNESS);
                const [child1, child2] = node.children;
                const availableHeight = parentRect.height - CONFIG.RESIZER_THICKNESS;
                const height1 = newSplit * availableHeight;
                const height2 = availableHeight - height1;

                // Drag-to-collapse logic for horizontal splits
                if (child1.isLeaf() && child1.isPinned) {
                    if (!child1.isCollapsed && height1 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                    else if (child1.isCollapsed && height1 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child1.id);
                }
                if (child2.isLeaf() && child2.isPinned) {
                    if (!child2.isCollapsed && height2 < CONFIG.COLLAPSED_SIZE - CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                    else if (child2.isCollapsed && height2 > CONFIG.COLLAPSED_SIZE + CONFIG.DRAG_COLLAPSE_THRESHOLD) this.toggleCollapse(child2.id);
                }

                node.split = newSplit;
            }
            this.layout();
        }

        initDrag() {
            this.activeDrag.isDragging = true;
            const draggedElement = this.activeDrag.target.element;
            this.enterPreviewMode(draggedElement);
            this.container.addEventListener('pointermove', this.handleDragOver);

            ['horizontal', 'horizontal', 'vertical', 'vertical'].forEach(direction => {
                const guide = document.createElement('div');
                guide.className = `alignment-guide ${direction}`;
                this.container.appendChild(guide);
                this.alignmentGuides.push(guide);
            });
        }
        
        handleDragOver(e) {
            if (!this.activeDrag?.isDragging) return;
            
            const containerRect = this.container.getBoundingClientRect();
            const relativeX = e.clientX - containerRect.left;
            const relativeY = e.clientY - containerRect.top;
            
            let targetPanel = null;
            let dropZone = null;
            
            const findTarget = (node) => {
                if (!node || targetPanel) return;
                if (node.isLeaf()) {
                    if (node.isPinned || node.element === this.activeDrag.target.element) return;
                    const rect = node.rect;
                    if (relativeX >= rect.x && relativeX <= rect.x + rect.width &&
                        relativeY >= rect.y && relativeY <= rect.y + rect.height) {
                            
                        targetPanel = node.element;
                        const x = relativeX - rect.x;
                        const y = relativeY - rect.y;
                        const w = rect.width;
                        const h = rect.height;

                        const distTop = y;
                        const distBottom = h - y;
                        const distLeft = x;
                        const distRight = w - x;

                        const minDist = Math.min(distTop, distBottom, distLeft, distRight);

                        if (minDist === distTop) {
                            dropZone = 'top';
                        } else if (minDist === distBottom) {
                            dropZone = 'bottom';
                        } else if (minDist === distLeft) {
                            dropZone = 'left';
                        } else {
                            dropZone = 'right';
                        }
                    }
                } else {
                    node.children.forEach(findTarget);
                }
            };
            findTarget(this.root);

            const hasChangedTarget = this.lastDragOverTarget.panelId !== (targetPanel?.dataset.panelId || null) || this.lastDragOverTarget.zone !== dropZone;

            if (targetPanel && dropZone && hasChangedTarget) {
                this.lastDragOverTarget = { panelId: targetPanel.dataset.panelId, zone: dropZone };
                this.activeDrag.currentTargetPanel = targetPanel;
                this.activeDrag.currentDropZone = dropZone;
                requestAnimationFrame(this.updatePreviewLayout);
            }

            this.layout(true);
        }
        
        updatePreviewLayout() {
            if (!this.isPreviewMode) return;
            
            this.previewRoot = this.root.clone();

            const { target, currentTargetPanel, currentDropZone } = this.activeDrag;
            if (currentTargetPanel && currentDropZone) {
                this.previewRoot = this._performMove(this.previewRoot, target.id, currentTargetPanel.dataset.panelId, currentDropZone);
            }
            
            this.layout(true);
        }

        _findNodeById(node, nodeId) {
            if (node.id === nodeId) return node;
            if (node.isLeaf()) return null;

            for (const child of node.children) {
                const found = this._findNodeById(child, nodeId);
                if (found) return found;
            }
            return null;
        }

        _isSubtreeFullyPinned(node) {
            if (node.isLeaf()) {
                return node.isPinned;
            }
            return node.children.every(child => this._isSubtreeFullyPinned(child));
        }

        _findLeafNodeById(tree, panelId) {
            if (tree.isLeaf()) {
                return tree.id === panelId ? tree : null;
            }
            for (const child of tree.children) {
                const found = this._findLeafNodeById(child, panelId);
                if (found) return found;
            }
            return null;
        }

        _performMove(tree, draggedId, targetId, zone) {
            if (draggedId === targetId) return tree;

            const draggedNode = this._findLeafNodeById(tree, draggedId);
            const targetNode = this._findLeafNodeById(tree, targetId);
            
            if (!draggedNode || !targetNode) return tree;

            // Detach dragged node
            const draggedParent = draggedNode.parent;
            if (draggedParent) {
                const sibling = draggedNode.getSibling();
                const grandparent = draggedParent.parent;
                if (grandparent) {
                    const parentIndex = grandparent.children.indexOf(draggedParent);
                    grandparent.children.splice(parentIndex, 1, sibling);
                    sibling.parent = grandparent;
                } else {
                    tree = sibling;
                    sibling.parent = null;
                }
            } else { return tree; } // Should not happen if tree is valid

            // Attach dragged node to target
            const targetParent = targetNode.parent;
            const direction = (zone === 'left' || zone === 'right') ? 'vertical' : 'horizontal';
            const children = (zone === 'left' || zone === 'top') ? [draggedNode, targetNode] : [targetNode, draggedNode];
            const newSplitNode = new BSPNode({ parent: targetParent, direction, children });

            draggedNode.parent = newSplitNode;
            targetNode.parent = newSplitNode;

            if (targetParent) {
                const targetIndex = targetParent.children.indexOf(targetNode);
                targetParent.children.splice(targetIndex, 1, newSplitNode);
            } else {
                tree = newSplitNode;
            }
            return tree;
        }

        enterPreviewMode(draggedElement) {
            this.isPreviewMode = true;
            this.previewRoot = this.root.clone();
            draggedElement.classList.add('is-dragging');
            this.container.classList.add('preview-mode');
            this.layout(true);
        }

        exitPreviewMode() {
            if (!this.isPreviewMode) return;
            
            this.alignmentGuides.forEach(guide => guide.remove());
            this.alignmentGuides = [];
            
            const draggedElement = this.activeDrag?.target.element;
            if (draggedElement) {
                draggedElement.classList.remove('is-dragging');
            }

            this.container.classList.remove('preview-mode');
            this.isPreviewMode = false;
            this.previewRoot = null;
            this.lastDragOverTarget = { panelId: null, zone: null };
            
            this.container.removeEventListener('pointermove', this.handleDragOver);
            this.saveState("Move Panel");
        }
        
        handleDrop() {
            const { currentTargetPanel, currentDropZone } = this.activeDrag;
            
            if (currentTargetPanel && currentDropZone) {
                this.root = this.previewRoot;

                this.panels.clear();
                const sync = (node) => {
                    if (node.isLeaf()) {
                        this.panels.set(node.id, { node, element: node.element });
                    } else {
                        node.children.forEach(sync);
                    }
                };
                sync(this.root);
                
                this.saveState("Move Panel");
            }
        }
        
        findNodeByElement(element) {
            const panelId = element.dataset.panelId;
            return this.panels.get(panelId)?.node;
        }

        createResizer(node, x, y, width, height, direction) {
            const resizer = document.createElement('div');
            resizer.className = `panel-resizer ${direction}`;
            resizer.dataset.nodeId = node.id;

            const [child1, child2] = node.children;
            const child1Pinned = this._isSubtreeFullyPinned(child1);
            const child2Pinned = this._isSubtreeFullyPinned(child2);
            const child1Collapsed = child1.isLeaf() && child1.isCollapsed;
            const child2Collapsed = child2.isLeaf() && child2.isCollapsed;

            if ((child1Pinned && child2Pinned) || child1Collapsed || child2Collapsed) {
                resizer.classList.add('is-disabled');
            }

            Object.assign(resizer.style, {
                left: `${x}px`, top: `${y}px`,
                width: `${width}px`, height: `${height}px`
            });
            this.container.appendChild(resizer);
            return resizer;
        }
        
        updatePanelControls(node) {
            if (!node.isLeaf()) return;
            const { element, rect } = node;

            const canSplitV = rect.width >= CONFIG.PANEL_MIN_WIDTH * 2 + CONFIG.RESIZER_THICKNESS;
            const canSplitH = rect.height >= CONFIG.PANEL_MIN_HEIGHT * 2 + CONFIG.RESIZER_THICKNESS;

            element.classList.toggle('is-pinned', node.isPinned);
            element.classList.toggle('is-collapsed', node.isCollapsed);

            // Add classes for collapse direction
            if (node.isCollapsed) {
                if (node.parent?.direction === 'horizontal') {
                    element.classList.add('is-collapsed-horizontally');
                    element.classList.remove('is-collapsed-vertically');
                } else { // 'vertical'
                    element.classList.add('is-collapsed-vertically');
                    element.classList.remove('is-collapsed-horizontally');
                }
            } else {
                element.classList.remove('is-collapsed-horizontally', 'is-collapsed-vertically');
            }

            const collapseBtn = element.querySelector('[data-action="collapse"]');
            if (collapseBtn) {
                const isAlwaysCollapsed = element.classList.contains('header-panel');
                const isCollapsible = node.isPinned && !isAlwaysCollapsed;
                collapseBtn.style.display = isCollapsible ? 'flex' : 'none';
            }

            const splitVBtn = element.querySelector('[data-action="split-v"]');
            if(splitVBtn) {
                splitVBtn.style.display = node.isPinned ? 'none' : 'flex';
                splitVBtn.disabled = !canSplitV || node.isCollapsed;
            }

            const splitHBtn = element.querySelector('[data-action="split-h"]');
            if(splitHBtn) {
                splitHBtn.style.display = node.isPinned ? 'none' : 'flex';
                splitHBtn.disabled = !canSplitH || node.isCollapsed;
            }
            
            const closeBtn = element.querySelector('[data-action="close"]');
            if(closeBtn) {
                closeBtn.style.display = node.isPinned ? 'none' : 'flex';
                closeBtn.disabled = (this.panels.size <= 1);
            }
        }

        togglePin(panelId) {
            const panel = this.panels.get(panelId);
            if (!panel) return;
            const { node } = panel;
            
            node.isPinned = !node.isPinned;
            // A panel cannot be both collapsed and unpinned
            if (!node.isPinned && node.isCollapsed) {
                node.isCollapsed = false;
            }
            this.layout(); // Recalculate layout to update resizer states
            this.saveState(`Pin panel ${node.isPinned ? 'on' : 'off'}`);

            this.history.on('change', ({ canUndo, canRedo }) => {
                if (this.dom.undoBtn) this.dom.undoBtn.disabled = !canUndo;
                if (this.dom.redoBtn) this.dom.redoBtn.disabled = !canRedo;
                
                const headerUndoBtn = document.getElementById('header-undo-btn');
                const headerRedoBtn = document.getElementById('header-redo-btn');
                if (headerUndoBtn) headerUndoBtn.disabled = !canUndo;
                if (headerRedoBtn) headerRedoBtn.disabled = !canRedo;
            });
        }

        toggleCollapse(panelId) {
            const panel = this.panels.get(panelId);
            if (!panel || !panel.node.isPinned) return;
            const { node, element } = panel;

            // Prevent header panel from being toggled, but allow action bar
            if (element.classList.contains('header-panel')) {
                return;
            }
            
            node.isCollapsed = !node.isCollapsed;

            // Move action buttons for action-bar-panel on collapse/expand
            if (element.classList.contains('action-bar-panel')) {
                const header = element.querySelector('.panel-header');
                const content = element.querySelector('.panel-content');
                const actionList = element.querySelector('.action-list');

                if (actionList && header && content) {
                    if (node.isCollapsed) {
                        header.appendChild(actionList);
                    } else {
                        content.appendChild(actionList);
                    }
                }
            }
            
            this.layout();
            this.saveState(`Collapse panel ${node.isCollapsed ? 'on' : 'off'}`);
        }

        setPanelMarkdown(panelId, markdown) {
            const panel = this.panels.get(panelId);
            if (!panel) return;

            this.markdownContent.set(panelId, markdown);
            this.setPanelHtml(panelId, this.markdownConverter.makeHtml(markdown));
        }

        setPanelHtml(panelId, html) {
            const panel = this.panels.get(panelId);
            if (!panel) return;
            const contentArea = panel.element.querySelector('.panel-content');
            if (contentArea) {
                contentArea.innerHTML = html;
            }
        }

        updateAlignmentGuides(rect) {
            if (this.alignmentGuides.length < 4) return;
            const [topGuide, bottomGuide, leftGuide, rightGuide] = this.alignmentGuides;

            topGuide.style.transform = `translateY(${rect.y}px)`;
            bottomGuide.style.transform = `translateY(${rect.y + rect.height}px)`;
            leftGuide.style.transform = `translateX(${rect.x}px)`;
            rightGuide.style.transform = `translateX(${rect.x + rect.width}px)`;
        }

        handleDoubleClick(e) {
            // Check if double-click is on panel content (not header, resizer, or buttons)
            const panelContent = e.target.closest('.panel-content');
            if (!panelContent) return;
            
            // Don't edit if clicking on buttons or interactive elements
            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('input')) {
                return;
            }
            
            const panel = panelContent.closest('.panel');
            if (!panel) return;
            
            const panelId = panel.dataset.panelId;
            if (!panelId) return;
            
            // Skip header panel
            if (panel.classList.contains('header-panel')) return;
            
            this.startMarkdownEdit(panelId, panelContent);
        }

        startMarkdownEdit(panelId, contentElement) {
            const currentMarkdown = this.markdownContent.get(panelId) || '';
            const panel = contentElement.closest('.panel');
            
            // Create textarea for editing
            const textarea = document.createElement('textarea');
            textarea.className = 'markdown-editor';
            textarea.value = currentMarkdown;
            textarea.placeholder = 'Enter markdown content...';
            
            // Style the textarea
            Object.assign(textarea.style, {
                width: '100%',
                height: '100%',
                border: 'none',
                outline: 'none',
                resize: 'none',
                fontFamily: 'inherit',
                fontSize: 'inherit',
                lineHeight: '1.5',
                padding: '10px',
                backgroundColor: 'var(--panel-bg)',
                color: 'var(--text-color)',
                boxSizing: 'border-box'
            });
            
            // Replace content with editor
            contentElement.innerHTML = '';
            contentElement.appendChild(textarea);
            
            // Focus and select all text
            textarea.focus();
            textarea.select();
            
            // Handle save
            const handleSave = () => {
                const newMarkdown = textarea.value;
                this.setPanelMarkdown(panelId, newMarkdown);
                this.saveState(`Edit panel ${panelId}`);
                this.exitMarkdownEdit(contentElement);
            };
            
            // Handle cancel
            const handleCancel = () => {
                this.exitMarkdownEdit(contentElement);
                // Restore original content
                const originalMarkdown = this.markdownContent.get(panelId) || '';
                this.setPanelHtml(panelId, this.markdownConverter.makeHtml(originalMarkdown));
            };
            
            // Auto-save on blur (clicking away)
            const handleBlur = () => {
                setTimeout(() => {
                    // Only save if we're still in edit mode (not cancelled)
                    if (this.currentEdit && this.currentEdit.textarea === textarea) {
                        handleSave();
                    }
                }, 100); // Small delay to allow for button clicks
            };
            
            // Keyboard shortcuts
            const handleKeyDown = (e) => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 's') {
                        e.preventDefault();
                        handleSave();
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    handleCancel();
                }
            };
            
            textarea.addEventListener('keydown', handleKeyDown);
            textarea.addEventListener('blur', handleBlur);
            
            // Store cleanup function
            this.currentEdit = {
                textarea,
                handleKeyDown,
                handleBlur,
                handleSave,
                handleCancel,
                contentElement
            };
        }

        exitMarkdownEdit(contentElement) {
            if (!this.currentEdit) return;
            
            const { textarea, handleKeyDown, handleBlur } = this.currentEdit;
            
            // Remove event listeners
            textarea.removeEventListener('keydown', handleKeyDown);
            textarea.removeEventListener('blur', handleBlur);
            
            // Clean up
            this.currentEdit = null;
        }

        saveLayoutToFile() {
            // Create layout data including tree structure and markdown content
            const layoutData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                tree: this.root.toJSON(),
                markdown: Object.fromEntries(this.markdownContent),
                panelCount: this.nextPanelNumber
            };

            // Convert to JSON string with pretty formatting
            const jsonString = JSON.stringify(layoutData, null, 2);
            
            // Create blob and download link
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create temporary download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `panel-layout-${new Date().toISOString().slice(0, 10)}.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            URL.revokeObjectURL(url);
        }

        loadLayoutFromFile() {
            // Create file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const layoutData = JSON.parse(e.target.result);
                        this.loadLayout(layoutData);
                    } catch (error) {
                        alert('Failed to load layout: Invalid JSON file');
                        console.error('Layout load error:', error);
                    }
                };
                reader.readAsText(file);
            });
            
            // Trigger file picker
            fileInput.click();
        }

        loadLayout(layoutData) {
            // Validate layout data
            if (!layoutData.tree || !layoutData.version) {
                alert('Invalid layout file format');
                return;
            }

            // Clear current layout
            this.container.innerHTML = '';
            this.panels.clear();
            this.resizers = [];
            this.history.clear();
            
            // Restore panel count
            this.nextPanelNumber = layoutData.panelCount || 1;
            
            // Restore markdown content
            this.markdownContent = new Map(Object.entries(layoutData.markdown || {}));
            
            // Create all panel elements first
            const panelElementsMap = new Map();
            const createPanelElements = (node) => {
                if (node.leaf) {
                    const element = this.createPanelElement(0); // Panel number will be set from title
                    element.dataset.panelId = node.id;
                    
                    // Set special classes if needed
                    if (node.isMainContent) {
                        // No special class needed for main content in this implementation
                    }
                    
                    panelElementsMap.set(node.id, element);
                } else if (node.children) {
                    node.children.forEach(createPanelElements);
                }
            };
            createPanelElements(layoutData.tree);
            
            // Rebuild BSP tree with element references
            this.root = BSPNode.fromJSON(layoutData.tree, null, panelElementsMap);
            
            // Sync panels map
            const syncPanels = (node) => {
                if (node.isLeaf()) {
                    this.panels.set(node.id, { node, element: node.element });
                    
                    // Extract panel number from existing title if available
                    const markdown = this.markdownContent.get(node.id) || '';
                    if (markdown && node.element) {
                        // Look for panel title in markdown or use a default
                        const titleMatch = markdown.match(/^###?\s*Panel\s*(\d+)/m);
                        if (titleMatch) {
                            const titleElement = node.element.querySelector('.panel-title');
                            if (titleElement) {
                                titleElement.textContent = `Panel ${titleMatch[1]}`;
                            }
                        }
                    }
                } else {
                    node.children.forEach(syncPanels);
                }
            };
            syncPanels(this.root);
            
            // Identify special panels based on position in tree
            // The structure should match what resetLayout creates
            let headerPanel = null;
            let actionBarPanel = null;
            
            // Navigate tree to find header and action bar panels
            if (this.root.children && this.root.children.length >= 2) {
                // Action bar should be first child of root
                const firstChild = this.root.children[0];
                if (firstChild.isLeaf()) {
                    actionBarPanel = this.panels.get(firstChild.id);
                    if (actionBarPanel) {
                        actionBarPanel.element.classList.add('action-bar-panel');
                    }
                }
                
                // Header panel should be in the structure
                const secondChild = this.root.children[1];
                if (secondChild.children && secondChild.children.length > 0) {
                    const topContent = secondChild.children[0];
                    if (topContent.children && topContent.children.length > 0) {
                        const headerAndLeft = topContent.children[0];
                        if (headerAndLeft.children && headerAndLeft.children.length >= 1) {
                            const possibleHeader = headerAndLeft.children[0];
                            if (possibleHeader.isLeaf()) {
                                headerPanel = this.panels.get(possibleHeader.id);
                                if (headerPanel) {
                                    headerPanel.element.classList.add('header-panel');
                                }
                            }
                        }
                    }
                }
            }
            
            // Set up header panel content
            if (headerPanel) {
                const markdownToolbar = `
                    <div class="markdown-toolbar">
                        <button class="btn" data-action="add-panel" title="Add Panel">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                        </button>
                        <button class="btn" data-action="reset-layout" title="Reset Layout">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
                        </button>
                        <button class="btn" data-action="undo" id="header-undo-btn" title="Undo (Ctrl+Z)" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                        </button>
                        <button class="btn" data-action="redo" id="header-redo-btn" title="Redo (Ctrl+Y)" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 14 5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                        </button>
                        <div class="toolbar-separator"></div>
                        <button class="btn" data-action="save-layout" title="Save Layout as JSON">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                        </button>
                        <button class="btn" data-action="load-layout" title="Load Layout from JSON">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M10 15l2 2 4-4"/></svg>
                        </button>
                    </div>
                `;
                this.setPanelHtml(headerPanel.node.id, markdownToolbar);

                // If header panel is collapsed on load, move toolbar to header
                if (headerPanel.node.isCollapsed) {
                    const toolbar = headerPanel.element.querySelector('.markdown-toolbar');
                    const header = headerPanel.element.querySelector('.panel-header');
                    if (toolbar && header) {
                        header.appendChild(toolbar);
                    }
                }
            }
            
            // Set up action bar panel content
            if (actionBarPanel) {
                const actionBarContent = `
                    <div class="action-bar-content">
                        <div class="action-list">
                            <button class="action-item" data-action="new-document" title="New Document">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>
                            </button>
                            <button class="action-item" data-action="open-file" title="Open File">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>
                            </button>
                            <button class="action-item" data-action="save" title="Save">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>
                            </button>
                        </div>
                    </div>
                `;
                this.setPanelHtml(actionBarPanel.node.id, actionBarContent);

                // If action bar panel is collapsed on load, move action buttons to header
                if (actionBarPanel.node.isCollapsed) {
                    const actionList = actionBarPanel.element.querySelector('.action-list');
                    const header = actionBarPanel.element.querySelector('.panel-header');
                    if (actionList && header) {
                        header.appendChild(actionList);
                    }
                }
            }
            
            // Restore markdown content for all panels
            this.panels.forEach((panel, id) => {
                if (!panel.element.classList.contains('header-panel') && !panel.element.classList.contains('action-bar-panel')) {
                    const markdown = this.markdownContent.get(id) || '';
                    if (markdown) {
                        this.setPanelMarkdown(id, markdown);
                    }
                }
            });
            
            // Final layout
            this.layout();
            this.saveState("Load Layout");
        }
    }

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', () => {
        const panelContainer = document.getElementById('panel-container');
        if (panelContainer) {
            window.panelManager = new PanelManager(panelContainer);
            window.panelManager.init();
        } else {
            console.error('Panel container not found.');
        }
    });

})();
